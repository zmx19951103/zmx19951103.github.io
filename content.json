{"meta":{"title":"ZMX's Blog","subtitle":null,"description":"code dog","author":"zmxdream","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-07-06T05:38:07.000Z","updated":"2019-08-06T06:08:32.354Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我是一名硕士研究生，这个博客主要用来记录我日常所学习的知识."},{"title":"links","date":"2019-07-23T02:53:56.000Z","updated":"2020-02-01T08:34:16.672Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"GPU ProgrammingLet’s build a simple databaseAI-Sys Spring 2019Systems for ML图解tensorflow源码Aurora 一个小型深度学习系统tinynn 一个轻量深度学习系统sysML2019MPI Tutorialcomputational graphNeuro_parallaxdoesbetterMIT 6.824https://www.nowcoder.com/ta/coding-interviews"},{"title":"tags","date":"2019-07-22T16:43:02.000Z","updated":"2019-07-22T16:44:15.120Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"信号量","slug":"信号量","date":"2020-07-22T07:29:18.000Z","updated":"2020-07-22T08:31:16.926Z","comments":true,"path":"2020/07/22/信号量/","link":"","permalink":"http://yoursite.com/2020/07/22/信号量/","excerpt":"","text":"前言信号量具备同步和互斥的语义(也就是 mutex+condition_variable).一个二元变量可以当作mutex使用, 可以解决生产者-消费者问题. 他和mutex很大的一个不同点在于mutex 要求是同一个线程上锁和解锁.而semaphore可以在一个线程执行P操作，在另一个线程执行V操作. 这也是信号量的问题，容易出错。所以c++11都弃用了. c++的 semphore 的类型是sem_t, 用 sem_init 初始化，P操作就是sem_wait, V操作就是sem_post, V操作将信号量加1，然后notify阻塞在这信号量上的进程. 例子leetcode 1114题 按序打印 #include &lt;semaphore.h&gt;class Foo &#123;protected: sem_t firstJobDone; sem_t secondJobDone;public: Foo() &#123; sem_init(&amp;firstJobDone, 0, 0); // 第二个参数是limit,表示信号量的可取的最大值，也就是同时能有多少线程能进入临界区 sem_init(&amp;secondJobDone, 0, 0); // 第三个参数就是初始量 &#125; void first(function&lt;void()&gt; printFirst) &#123; // printFirst() outputs \"first\". printFirst(); sem_post(&amp;firstJobDone); &#125; void second(function&lt;void()&gt; printSecond) &#123; sem_wait(&amp;firstJobDone); // printSecond() outputs \"second\". printSecond(); sem_post(&amp;secondJobDone); &#125; void third(function&lt;void()&gt; printThird) &#123; sem_wait(&amp;secondJobDone); // printThird() outputs \"third\". printThird(); &#125;&#125;; 参考semaphore","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"future,promise,packaged_task,async","slug":"future-promise-packaged-task-async","date":"2020-07-22T03:47:42.000Z","updated":"2020-07-22T04:02:34.331Z","comments":true,"path":"2020/07/22/future-promise-packaged-task-async/","link":"","permalink":"http://yoursite.com/2020/07/22/future-promise-packaged-task-async/","excerpt":"","text":"前言c++11有很多异步操作相关的库，相比thread可以更加方便的得到异步操作的结果. 例子 Std::future 作为异步结果的传输通道，方便的获取线程函数的返回值 Std::promise 包装一个值，将数据和future绑定起来，方便线程赋值 Std::package_task 包装一个可调用对象，将函数和future绑定，以便异步调用 Std::future如果我们要拿到线程的返回值，再没有future之前是需要定义一个变量，然后在线程函数中对这个变量赋值，然后等待线程函数操作完成，我们拿到结果,这样很繁琐.用来获取异步操作的结果，可以通过不断查询future的状态来得到异步操作的状态，一个future 的状态有: Deferred: 异步操作还未开始 Ready: 异步操作已经完成 TimeOut: 异步操作超时获取 future的结果有三种，get(), wait(), wait_for()Get()就是最常用的等待异步操作结束，然后拿到结果， wait就是等待异步操作结束，没有拿返回值，wait_for是超时等待并拿返回值, future的模板参数是返回结果的类型. Std::promise 协助线程赋值的类将数据和future绑定， 这个绑定的含义如何理解. 其实就是可以更加方便的拿到线程中的值，在线程中给从外面传进来的 std::promise 对象赋值. std::promise&lt;int&gt; pr;std::thread t([](std::promise&lt;int&gt; &amp; p)&#123; p.set_value_at_thread_exit(8);&#125;, std::ref(pr));t.detach();std::future&lt;int&gt; ret = pr.get_future();auto r = ret.get();std::cout &lt;&lt; r &lt;&lt; std::endl; Std::packaged_task将函数和future绑定, 其实它就是封装了一个可调用对象， 然后用thread执行，然后从 Std::packaged_task 对象中拿到 future，获取返回值，这个拿future 可以是创建线程之前或者之后. std::packaged_task&lt;int()&gt; task([]()-&gt;int&#123;return 9;&#125;);std::future&lt;int&gt; f2= task.get_future();std::thread t2(std::move(task));t2.detach(); Std::async线程异步操作函数，可以代替std::thread, 返回类型是一个future。 /* * std::async */ std::vector&lt;std::future&lt;int&gt;&gt; v; auto f = std::async(std::launch::async, [](int a, int b)-&gt;int &#123; return a + b;&#125;, 2, 3); v.push_back(std::move(f)); std::cout &lt;&lt; \"the shared_future result is \" &lt;&lt; v[0].get() &lt;&lt; std::endl; 参考future","categories":[],"tags":[{"name":"c++11","slug":"c-11","permalink":"http://yoursite.com/tags/c-11/"}]},{"title":"摩尔投票法","slug":"摩尔投票法","date":"2020-07-18T16:19:26.000Z","updated":"2020-07-19T09:56:11.052Z","comments":true,"path":"2020/07/19/摩尔投票法/","link":"","permalink":"http://yoursite.com/2020/07/19/摩尔投票法/","excerpt":"","text":"前言leetcode多数元素这一道题，一开始想法是用一个hashmap, 时间复杂度是O(n), 空间复杂度是O(n). 用摩尔投票法能把空间复杂度优化到O(1). 实践 leetcode第169题 class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; // 我一开始想到的是 用一个hashmap // 时间复杂度O(n), 空间复杂度O(n), 我们可以用摩尔投票把空间复杂度降到O(1) // // std::unordered_map&lt;int,int&gt; mapp; // int length = nums.size(); // for(auto &amp; e : nums) &#123; // mapp[e]++; // if(mapp[e] &gt; length / 2) return e; // &#125; // return -1; // 摩尔投票法 // 删除任意两个不同的数，直到只剩下一个或两个数,剩下的数就是多数元素 // 数组遍历完以后, 剩下的数应该用一个变量保存 if(nums.size() == 1) return nums[0]; int ret = nums[0]; int count = 1; for(int i = 1;i &lt; nums.size();i++) &#123; if(count == 0) &#123; ret = nums[i]; count++;&#125; else&#123; if(nums[i] != ret) count--; else count++; &#125; &#125; // 其实最后需要确认一下是不是真的是多数元素 // 因为村子 [a,b,c]这种情况 // 那么最后剩下的c也不是多数元素，但是这里题目假设了有多数元素 int count_ = 0; for(auto &amp; e : nums ) if(e == ret) count_++; if(count_ &gt; nums.size() / 2) return ret; else return -1; &#125;&#125;; leetcode第229题，求众数2 class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; // 算法时间复杂度是O(n),空间复杂度是O(1) // 摩尔投票 // 最多两个众数 if(nums.size() &lt;=1 ) return nums; if(nums.size()== 2) &#123; if(nums[0]!=nums[1]) return nums; else return &#123;nums[0]&#125;; &#125; int ret1= nums[0], ret2 = nums[1]; int cnt1 = 1, cnt2 = 1; int start = -1; for(int i= 1; i &lt; nums.size();i++) &#123; if(nums[i] != ret1) &#123;ret2 = nums[i]; start = i; break;&#125; else &#123;cnt1++;&#125; &#125; if(ret2 == ret1) return &#123;ret1&#125;; for(int i = start + 1 ; i &lt; nums.size();i++) &#123; if(nums[i] == ret1) &#123;cnt1++; continue;&#125; else if(nums[i] ==ret2) &#123;cnt2++; continue;&#125; if(cnt1==0)&#123; cnt1 =1; ret1 = nums[i];&#125; else if(cnt2 == 0) &#123;cnt2 =1; ret2= nums[i];&#125; else &#123; // cnt1 !=0 &amp;&amp; cnt2 != 0 // if(nums[i] == ret1) &#123;cnt1++;&#125; // else if(nums[i] ==ret2) &#123;cnt2++;&#125; cnt1--;cnt2--; &#125; &#125; std::vector&lt;int&gt; ret_val; // if(cnt1)&#123; int count1 = 0,count2=0; for(auto &amp; e: nums) &#123; if (cnt1 &amp;&amp; e == ret1) count1++; else if (cnt2 &amp;&amp; e == ret2) count2++; &#125; if(count1 &gt; nums.size() / 3) ret_val.push_back(ret1); // &#125; // if(cnt2)&#123; // int count = 0; // for(auto &amp; e: nums) &#123;if (e == ret2) count++;&#125; if(count2 &gt; nums.size() / 3) ret_val.push_back(ret2); //&#125; return ret_val; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"bitset","slug":"bitset","date":"2020-06-24T03:53:31.000Z","updated":"2020-06-27T16:37:47.432Z","comments":true,"path":"2020/06/24/bitset/","link":"","permalink":"http://yoursite.com/2020/06/24/bitset/","excerpt":"","text":"bitset就是位集.和数组类似，其中的每个元素都是1个bit. 参考 bitset","categories":[],"tags":[{"name":"data structure","slug":"data-structure","permalink":"http://yoursite.com/tags/data-structure/"}]},{"title":"mutable关键字","slug":"mutable关键字","date":"2020-04-05T09:43:26.000Z","updated":"2020-04-05T13:51:49.774Z","comments":true,"path":"2020/04/05/mutable关键字/","link":"","permalink":"http://yoursite.com/2020/04/05/mutable关键字/","excerpt":"","text":"前言mutable是c++中的一个关键字,它的应用场景是在类的const成员函数中.当我们想要在类的const成员函数中修改类的某些数据成员的时候，就会用到这个关键字. mutable数据成员用const修饰的成员函数表示该该函数不会修改调用该函数的对象的内部状态,const object 只能调用 const member function, 如果要在const member function里修改对象的数据成员是不被允许的，因为这样会破坏对象的常量性.但是如果必须要修改某些成员，就要用到mutable关键字，它表明修改该数据成员不会破坏对象的常量性. 例子#include&lt;iostream&gt;using namespace std;class A&#123;public: void test() const&#123; c = 8; std::cout &lt;&lt; \"a\" &lt;&lt; std::endl; &#125; void test() &#123; std::cout &lt;&lt; \"b\" &lt;&lt; std::endl; &#125; mutable int c = 9;&#125;;int main()&#123; A a; const A a_; a.test(); a_.test(); return 0;&#125; 上述代码编译通过， 并且还可以看到非const对象在const成员函数和非const成员函数中优先调用非const成员函数.","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Reactor模式","slug":"Reactor模式","date":"2020-03-21T11:30:58.000Z","updated":"2020-03-21T11:32:28.767Z","comments":true,"path":"2020/03/21/Reactor模式/","link":"","permalink":"http://yoursite.com/2020/03/21/Reactor模式/","excerpt":"","text":"前言Reactor模式是许多高性能网络库比如libevent和netty基于的模式","categories":[],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"}]},{"title":"使用tcpdump分析tcp协议","slug":"使用tcpdump分析tcp协议","date":"2020-03-21T06:34:30.000Z","updated":"2020-03-21T06:34:30.700Z","comments":true,"path":"2020/03/21/使用tcpdump分析tcp协议/","link":"","permalink":"http://yoursite.com/2020/03/21/使用tcpdump分析tcp协议/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"无锁编程","slug":"无锁编程","date":"2020-03-18T08:57:18.000Z","updated":"2020-03-18T08:57:18.813Z","comments":true,"path":"2020/03/18/无锁编程/","link":"","permalink":"http://yoursite.com/2020/03/18/无锁编程/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RAII资源获取即初始化","slug":"RAII资源获取即初始化","date":"2020-03-18T08:56:26.000Z","updated":"2020-03-18T08:56:26.317Z","comments":true,"path":"2020/03/18/RAII资源获取即初始化/","link":"","permalink":"http://yoursite.com/2020/03/18/RAII资源获取即初始化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"进程调度算法","slug":"进程调度算法","date":"2020-03-18T08:47:58.000Z","updated":"2020-03-18T08:47:58.861Z","comments":true,"path":"2020/03/18/进程调度算法/","link":"","permalink":"http://yoursite.com/2020/03/18/进程调度算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"线程安全，可重入","slug":"线程安全，可重入","date":"2020-03-18T08:47:49.000Z","updated":"2020-03-18T08:47:49.911Z","comments":true,"path":"2020/03/18/线程安全，可重入/","link":"","permalink":"http://yoursite.com/2020/03/18/线程安全，可重入/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Python装饰器","slug":"Python装饰器","date":"2020-03-18T07:56:31.000Z","updated":"2020-03-18T08:44:07.226Z","comments":true,"path":"2020/03/18/Python装饰器/","link":"","permalink":"http://yoursite.com/2020/03/18/Python装饰器/","excerpt":"","text":"前言Python的装饰器是面试经常会问的问题，今天来学习一下Python的装饰器语法. 参考python装饰器","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"队列最大值","slug":"队列最大值","date":"2020-03-17T14:51:42.000Z","updated":"2020-03-18T02:21:07.543Z","comments":true,"path":"2020/03/17/队列最大值/","link":"","permalink":"http://yoursite.com/2020/03/17/队列最大值/","excerpt":"","text":"前言这道题用单调队列做，当你插入一个新元素以后，保证单调队列的队头元素永远是最大的，用单调递减队列。我们需要从队尾pop元素，从队头pop元素，所以用deque双端队列。 代码class MaxQueue &#123;public: MaxQueue() &#123; &#125; int max_value() &#123; if(que.empty()) return -1; else return deq.front(); &#125; void push_back(int value) &#123; if(deq.empty()) deq.push_back(value); else &#123; while(!deq.empty() &amp;&amp; deq.back() &lt; value) deq.pop_back(); deq.push_back(value); &#125; que.push(value); &#125; int pop_front() &#123; if(que.empty()) return -1; else &#123; int ele = que.front(); que.pop(); //如果 ele == max_value if(ele == deq.front()) deq.pop_front(); return ele; &#125; &#125; std::queue&lt;int&gt; que; std::deque&lt;int&gt; deq;&#125;;/** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-&gt;max_value(); * obj-&gt;push_back(value); * int param_3 = obj-&gt;pop_front(); */","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"STL迭代器失效的问题","slug":"STL迭代器失效的问题","date":"2020-03-11T03:19:06.000Z","updated":"2020-03-11T05:39:13.590Z","comments":true,"path":"2020/03/11/STL迭代器失效的问题/","link":"","permalink":"http://yoursite.com/2020/03/11/STL迭代器失效的问题/","excerpt":"","text":"前言在腾讯的面试中遇到这个问题才发现自己对STL的掌握是在是太缺乏了，同理还有对网络编程和多线程编程以及操作系统的系统性知识的缺乏，后续都要补，不然秋招的时候就惨了.下面我们就来讨论STL迭代器失效的问题. STL迭代器失效的问题我们要对STL迭代器失效的问题进行全盘的考虑，因为底层的实现有连续内存，list,rbtree以及hash table,我们要分别考虑这些底层数据结构下的迭代器失效的问题. vector迭代器失效vector 迭代器失效的时机是如果没有重分配发生的话，指向insert pointer之前的所有迭代器都不会失效，但是insert pointer之后的迭代器都会失效.如果有重分配发生的话，那么指向原容器的所有迭代器都会失效. list迭代器失效unordered_set 和 unordered_map的迭代器失效set和map的迭代器失效参考[vector迭代器失效的思考]（https://www.cnblogs.com/qiaoconglovelife/p/5370396.html）","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"TopN","slug":"TopN","date":"2020-03-02T07:09:39.000Z","updated":"2020-03-02T07:20:31.233Z","comments":true,"path":"2020/03/02/TopN/","link":"","permalink":"http://yoursite.com/2020/03/02/TopN/","excerpt":"","text":"前言TopN问题是面试中的高频面试问题,主要两个思路，一个是分治，一个是用堆. 参考TopN","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"STL_treemap,hashmap实现","slug":"STL-treemap-hashmap实现","date":"2020-02-16T14:06:42.000Z","updated":"2020-02-16T14:35:09.515Z","comments":true,"path":"2020/02/16/STL-treemap-hashmap实现/","link":"","permalink":"http://yoursite.com/2020/02/16/STL-treemap-hashmap实现/","excerpt":"","text":"前言","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"最短无序连续子数组","slug":"最短无序连续子数组","date":"2020-02-15T17:16:03.000Z","updated":"2020-02-16T08:17:25.900Z","comments":true,"path":"2020/02/16/最短无序连续子数组/","link":"","permalink":"http://yoursite.com/2020/02/16/最短无序连续子数组/","excerpt":"","text":"前言这道题我一开始的想法是就是找到这个无序子数组的左右边界,怎么找呢，一个数如果它不在它应该在的位置，那么这个数肯定在子数组的范围内，那么我们只要找到在这个范围内的数在最左边和最右边的数，那么就可以了，我首先想到的办法是排序，然后遍历，复杂度是O(nlogn),空间复杂度是O(n). 其实这道题还可以用单调栈来做，时间复杂度可以优化到O(n),其实想一想按照单调栈的实现,我们就可以得到这个数组从哪个位置开始的数是不应该在这个位置的。 代码","categories":[],"tags":[{"name":"前言","slug":"前言","permalink":"http://yoursite.com/tags/前言/"}]},{"title":"状态压缩dp","slug":"状态压缩dp","date":"2020-02-06T17:00:01.000Z","updated":"2020-02-06T17:00:01.286Z","comments":true,"path":"2020/02/07/状态压缩dp/","link":"","permalink":"http://yoursite.com/2020/02/07/状态压缩dp/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"滚动数组","slug":"滚动数组","date":"2020-02-06T16:59:50.000Z","updated":"2020-02-06T16:59:50.776Z","comments":true,"path":"2020/02/07/滚动数组/","link":"","permalink":"http://yoursite.com/2020/02/07/滚动数组/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"“马拉车算法”","slug":"“马拉车算法”","date":"2020-02-06T02:47:20.000Z","updated":"2020-02-06T02:47:20.583Z","comments":true,"path":"2020/02/06/“马拉车算法”/","link":"","permalink":"http://yoursite.com/2020/02/06/“马拉车算法”/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"连续的子数组和","slug":"连续的子数组和","date":"2020-02-04T15:27:59.000Z","updated":"2020-02-04T15:28:27.896Z","comments":true,"path":"2020/02/04/连续的子数组和/","link":"","permalink":"http://yoursite.com/2020/02/04/连续的子数组和/","excerpt":"","text":"前言","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"“和为k的子数组”","slug":"“和为k的子数组”","date":"2020-02-04T14:18:26.000Z","updated":"2020-02-04T14:29:14.355Z","comments":true,"path":"2020/02/04/“和为k的子数组”/","link":"","permalink":"http://yoursite.com/2020/02/04/“和为k的子数组”/","excerpt":"","text":"前言这道题的思想和两数之和的思想有点像，都用了哈希表来优化时间复杂度, 这道题的思想是我们要找到一个和为k的子数组,那么就是一个区间i-j， 使得sum[j]-sum[i-1]==k. 这里的sum为前缀和数组。对于j来说，我们其实不需要知道具体的i，因为题目只需要计算数组的个数，这样我们只需要知道有多少个i，i&lt;j,使得 sum[j]-sum[i-1] ==k, 想到这里我们就知道要记录前缀和的出现频率，这样我们在遍历到j位置的时候，通过哈希表就可以查到 前缀和为sum[j]-k的索引个数. 代码class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; std::unordered_map&lt;int,int&gt; mapping; int sum =0; int cnt=0; mapping[0] =1; for(int i =0;i&lt;nums.size();i++)&#123; sum+=nums[i]; if(mapping.find(sum-k)!=mapping.end()) cnt+=mapping[sum-k]; mapping[sum]++; &#125; return cnt; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"并查集","slug":"并查集","date":"2020-02-01T17:33:19.000Z","updated":"2020-02-08T11:41:39.388Z","comments":true,"path":"2020/02/02/并查集/","link":"","permalink":"http://yoursite.com/2020/02/02/并查集/","excerpt":"","text":"前言并查集是一种数据结构，它支持查询两个元素是否属于同一个集合以及集合之间的合并. 在基本的代码实现上有两个优化:路径压缩和按秩合并. 参考并查集","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"LRU缓存机制","slug":"LRU缓存机制","date":"2020-02-01T07:50:13.000Z","updated":"2020-02-01T08:22:35.293Z","comments":true,"path":"2020/02/01/LRU缓存机制/","link":"","permalink":"http://yoursite.com/2020/02/01/LRU缓存机制/","excerpt":"","text":"前言题目要求在O(1)的时间复杂度内完成get(key)和put(key,value)的操作, 每次get或者put的操作都会更新一下对应key的”活跃度“， 如果要选择一个缓存页换出的话，每次会选择最近最久未使用的页面,要在O(1)时间内更新页面活跃度的话，我们必须知道这个页面的位置，然后将页面放到一个可以直接存取的位置，每次要换出页面直接将该位置的页面换出即可. 首先我们用一个容器来存储所有页面，每次访问一个页面，如果这个页面在容器的中间，我们需要将这个页面移动到容器的最前端，然后每次如果要更换页面，我们更换容器尾端的页面. 这里我们要保证从容器中移除页面是O(1)的时间复杂度,像vector,deque底部都是数组，删除元素需要移动被删除元素后面的元素，所以不是O(1)，删除元素要做到O(1)要用链表. 我们用c++的list容器，其实这里用单向链表就行了，list是双向循环链表. 代码class LRUCache &#123;public: LRUCache(int capacity) &#123; cap = capacity; &#125; int get(int key) &#123; if(mapping.find(key) == mapping.end() ) return -1; else &#123; int value = mapping[key]-&gt;second; lis.erase(mapping[key]); lis.push_front(&#123;key,value&#125;); mapping[key] = lis.begin(); return value; &#125; &#125; void put(int key, int value) &#123; if(mapping.find(key) != mapping.end() )&#123; lis.erase(mapping[key]); &#125; if(lis.size() == cap)&#123; mapping.erase(lis.back().first); lis.pop_back(); &#125; lis.push_front(&#123;key,value&#125;); mapping[key] = lis.begin(); &#125; unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator &gt; mapping; list&lt;pair&lt;int,int&gt;&gt; lis; int cap;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ 我们用list存储 k,v对， 然后用一个hashmap存储key和对应pair的迭代器的映射就行了.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"编辑距离","slug":"编辑距离","date":"2020-01-30T13:35:59.000Z","updated":"2020-02-01T07:49:56.372Z","comments":true,"path":"2020/01/30/编辑距离/","link":"","permalink":"http://yoursite.com/2020/01/30/编辑距离/","excerpt":"","text":"前言这道题是动态规划的必考题了,","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"复制带随机指针的链表","slug":"复制带随机指针的链表","date":"2020-01-30T13:28:23.000Z","updated":"2020-01-30T13:35:17.268Z","comments":true,"path":"2020/01/30/复制带随机指针的链表/","link":"","permalink":"http://yoursite.com/2020/01/30/复制带随机指针的链表/","excerpt":"","text":"前言一开始这道题我用一个map，存储旧节点和新节点的映射， 然后我遍历一遍把整个链表结构先复制了，也就是设置好每个节点的next指针，然后把旧节点和新节点的映射存入map, 然后再遍历一遍，设置 每个节点random的值, 时间复杂度和空间复杂度都是O(n). 看了一下题解，空间复杂度还可以更加优化到O(1),做法是把复制的节点放到对应旧节点的next,这样得到一个旧新交替的新链表，其实就是模拟了一个map,因为我们知道旧节点对应的新节点就是旧节点的next，实现了map的功能，比较巧妙,然后设置完random以后，还要把新旧交替的链表再重新设置回原来的样子，返回新节点组成的链表. 代码/*// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;*/class Solution &#123;public: Node* copyRandomList(Node* head) &#123; // 返回链表的深拷贝 if(head == NULL) return head; // std::unordered_map&lt;Node*,Node*&gt; mapping; // Node* p = head;// Node* q = new Node(-1);// Node * new_node = q; // while(p)&#123; // Node* temp = new Node(p-&gt;val);// mapping[p] = temp;// q-&gt;next= temp; // q = temp;// p = p-&gt;next;// &#125; // p = head , q = new_node-&gt;next; // while(p&amp;&amp;q)&#123;// q-&gt;random = mapping[p-&gt;random];// p=p-&gt;next; q = q-&gt;next;// &#125; // return new_node-&gt;next; Node* p = head; while(p)&#123; Node* temp = new Node(p-&gt;val); temp-&gt;next = p-&gt;next; // Node* nex = p-&gt;next; p-&gt;next= temp; p = temp-&gt;next; &#125; p = head; while(p)&#123; Node* q = p-&gt;next; if(p-&gt;random) q-&gt;random = p-&gt;random-&gt;next; else q-&gt;random = NULL; p = q-&gt;next; &#125; p = head; Node * ret = head-&gt;next; // 还原是最麻烦的 while(p)&#123; Node* pp = p-&gt;next; Node* q = pp-&gt;next; Node* qq; if(q) qq = q-&gt;next; else qq = NULL; p-&gt;next = q; pp-&gt;next = qq; p = q; &#125; return ret; &#125;&#125;; 时间复杂度是O(n),空间复杂度只要O(1).","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"会议室II","slug":"会议室II","date":"2020-01-30T06:32:27.000Z","updated":"2020-01-30T06:34:53.818Z","comments":true,"path":"2020/01/30/会议室II/","link":"","permalink":"http://yoursite.com/2020/01/30/会议室II/","excerpt":"","text":"前言这道题的重点在于维护已有会议室中的最早结束时间，我们按照开始时间对会议进行排序，新来一个会议，只要它的开始时间比已有会议室中最早的结束时间要晚，那么就不需要新的会议室. 代码class Solution &#123;public: static bool help(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123; return a[0]&lt; b[0]; &#125; int minMeetingRooms(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; if(intervals.empty()) return 0; // 充分利用会议室资源 // 统计同时一起开的会议有多少 // 只要一个变量记录所有会议室的早结束时间就可以了，首先排序 // 比如第一个例子， 遇到[0,30],需要一间，time= 30 , // 遇到[5,10], 因为time=30 &gt; 5(start_time),那么需要一间，更新time=10 // 遇到[15,20], 15 &gt; time =10, 所以不需要新的房间 std::sort(intervals.begin(),intervals.end(),help); //int end_time = intervals[0][1]; std::priority_queue&lt;int,vector&lt;int&gt;, greater&lt;int&gt; &gt; end_time; end_time.push(intervals[0][1]); int cnt = 1; for(int i = 1;i&lt; intervals.size();i++)&#123; if(intervals[i][0] &lt; end_time.top()) &#123; cnt ++ ; end_time.push(intervals[i][1]);&#125; else &#123; end_time.pop(); end_time.push(intervals[i][1]); &#125; &#125; return cnt; &#125;&#125;;// [2,15],[4,9],[9,29],[16,23],[36,45]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"全排列II","slug":"全排列II","date":"2020-01-29T18:24:26.000Z","updated":"2020-01-29T19:08:02.292Z","comments":true,"path":"2020/01/30/全排列II/","link":"","permalink":"http://yoursite.com/2020/01/30/全排列II/","excerpt":"","text":"前言这又是一道回溯算法的题，与全排列I不同的是，这道题允许有重复的元素,基本思路和全排列I一样，但是为了去重，会引入一些剪枝的逻辑 代码class Solution &#123;public: void help(vector&lt;int&gt; &amp;nums,int level)&#123; int size = nums.size(); if(level == size)&#123; ret.push_back(nums); return; &#125; for(int i = level ; i &lt; size ; i++) &#123; // 主要增加的就是这部分剪枝的逻辑，目的是为了同一层不要出现一样的数，因为同一层出现一样的数，下一层的遍历肯定是相同的 if( i!=level)&#123; bool flag = false; for(int j = i-1 ;j &gt;= level;j--) if(nums[j] == nums[i]) flag = true; if(flag) continue; &#125; std::swap(nums[level],nums[i]); help(nums,level+1); std::swap(nums[level],nums[i]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); help(nums,0); return ret; &#125; vector&lt;vector&lt;int&gt;&gt; ret; &#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"组合总和","slug":"组合总和","date":"2020-01-29T15:42:55.000Z","updated":"2020-01-29T18:10:47.172Z","comments":true,"path":"2020/01/29/组合总和/","link":"","permalink":"http://yoursite.com/2020/01/29/组合总和/","excerpt":"","text":"前言这道题就是一道回溯，不过要去重，在递归的过程中去重，我们把原来的数组排序，然后当前选取的数不能比上一个选取的数小就能达到去重的目的. 代码class Solution &#123;public: void helper(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; res, int target)&#123; if(target&lt;0) return; if ( target == 0 ) &#123; ret.push_back(res); return; &#125; int size= candidates.size(); for(int i =0;i&lt;size;i++)&#123; if(candidates[i] &lt;= target) &#123; if(res.size() &gt;0 &amp;&amp; candidates[i] &lt; res[res.size()-1]) continue; res.push_back(candidates[i]); helper(candidates,res,target-candidates[i]); res.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;int&gt; res =&#123;&#125;; std::sort(candidates.begin(),candidates.end()); helper(candidates,res,target); return ret; &#125; vector&lt;vector&lt;int&gt;&gt; ret;&#125;; 组合总和II这道题和前面一道的区别在于，每个数现在只能使用一次，而且现在的数组有重复的数，为了达到每个数只能使用一次而且结果不能重复的目的，我用了一个used数组， 但是发现因为candidates数组中有重复的数字，所以没用， 为什么没用，假设有这么一个例子[10,1,2,7,6,1,5] ,排序后是 1,1,2,5,6,7,10，你遍历完以第一个1开头的所有可行解以后，第一个1标记为未使用的，那么下面要遍历以第二个1开始的所有可行解，这时候遍历还是从0开始的话，第一个1就又被放进去了,所以我用索引开始的位置来去重,当前数的索引为i，那么进入下一层递归的开始遍历索引为i+1,可以保证不会出现上面的问题。下面说一下为啥要排序，排序可以解决另一个重复问题,还是上面的数组，target是8 , 那么 1(1),2,5是一个可行解，括号里的1表示是数组中的第一个1,下面第一层遍历到第二个1，它还是能得到1(2),2,5,造成重复，其实这时候第二个1应该跳过，只要索引不是这一层的start而且 candidates[i] == candidates[i-1]就可以跳过，为什么不是start就可以跳过，因为不是start的话，说明在这一层，以这个数开头的已经遍历过了，虽然元素不是重复的，但是整体的结果是重复的，比如1(1),2,5和 1(2),2,5. class Solution &#123;public: void helper(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; res, int start, int target)&#123; if(target&lt;0) return; if ( target == 0 ) &#123; ret.push_back(res); return; &#125; int size= candidates.size(); for(int i =start;i&lt;size;i++)&#123; if( i!= start &amp;&amp; candidates[i] == candidates[i-1]) continue; // 这段代码非常重要，在全排列II中也用到 if(candidates[i] &lt;= target) &#123; res.push_back(candidates[i]); helper(candidates,res,i+1,target-candidates[i]); res.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;int&gt; res =&#123;&#125;; int size = candidates.size(); std::sort(candidates.begin(),candidates.end()); helper(candidates,res,0,target); return ret; &#125; &#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"两整数之和","slug":"两整数之和","date":"2020-01-29T09:17:45.000Z","updated":"2020-01-29T09:25:41.281Z","comments":true,"path":"2020/01/29/两整数之和/","link":"","permalink":"http://yoursite.com/2020/01/29/两整数之和/","excerpt":"","text":"前言这道题要求不用+和-两个运算符，实现两个整数的加法. 我们用异或和与两个位运算来实现+运算符 思考异或操作符，我们知道如果对应位上是相同的则为0，否则为1. 这和加法相同，但是有一点不同，异或操作没有进位的概念，如果相应的位上都是1，那么应该有一个向前的进位，那我们如何知道这个位上有没有向前的进位呢， 我们用与运算，如果两个都是1，结果才是1， 但是进位是向前的，所以我们需要将与运算的结果左移一位然后和异或的结果继续相加，相加的话还是用异或来得到，那么还是没有进位，还要与，直到异或没有进位为止. 需要注意的是如果与操作的结果是一个负数，负数左移会报错，所以先转换成 unsigned int再左移. 代码class Solution &#123;public: int getSum(int a, int b) &#123; int t = a^b; int p = a&amp;b; while(p)&#123; p = (unsigned int)p &lt;&lt; 1; int temp = t; t = t ^ p; p = temp &amp; p; &#125; return t; &#125;&#125;; 参考两整数之和","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"跳跃游戏","slug":"跳跃游戏","date":"2020-01-27T18:36:29.000Z","updated":"2020-01-27T18:51:53.268Z","comments":true,"path":"2020/01/28/跳跃游戏/","link":"","permalink":"http://yoursite.com/2020/01/28/跳跃游戏/","excerpt":"","text":"前言这道题是一道一维的dp问题，用dp[i] 表示是否能到到当前位置i, 因为从第0个元素出发，所以dp[0] =1, 转移方程是 对于 dp[i] :for(int j = i-1, j&gt;=0 ; j--) if(dp[j] &amp;&amp; nums[j] &gt;= i-j) &#123; dp[i] =1 ; break; &#125; 只要找到有一个位置能够到当前位置i,就行了，为了效率问题，需要逆序遍历,试了一下,顺序变了一下,效率差了很多很多.完整代码如下: class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; // 二维dp // 其实一维就够了，只需要知道从第0个位置能否到当前位置就行了 int size = nums.size(); std::vector&lt;int&gt; dp(size,0); // dp[i][j] means whether i to j is ok dp[0] =1 ; for(int i = 1; i &lt; size ;i++ )&#123; // if(i ==0) dp[i] = 1; // else&#123; for(int j = i-1 ;j &gt;=0; j--) &#123; if(dp[j] &amp;&amp; nums[j] &gt;= i-j) &#123; dp[i] =1 ; break;&#125; &#125; &#125; return dp[size-1]; &#125;&#125;; 从上面的注释来看，我一开始想的是二维dp,后来超内存，然后一想只要一维就够了.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"CTR预估实践","slug":"CTR预估实践","date":"2020-01-27T15:50:35.000Z","updated":"2020-01-27T15:50:35.143Z","comments":true,"path":"2020/01/27/CTR预估实践/","link":"","permalink":"http://yoursite.com/2020/01/27/CTR预估实践/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"颜色分类","slug":"颜色分类","date":"2020-01-27T06:04:17.000Z","updated":"2020-01-27T06:08:49.167Z","comments":true,"path":"2020/01/27/颜色分类/","link":"","permalink":"http://yoursite.com/2020/01/27/颜色分类/","excerpt":"","text":"前言这道题本质不是一个排序问题吗…还要原地操作, 可以用快排，也可以用三个指针的操作 代码class Solution &#123;public: void quick(vector&lt;int&gt;&amp; nums, int left , int right )&#123; if(left&gt;=right)return; int pivot = nums[left]; int i = left+1, j = right; while(i &lt;= j)&#123; while(i &lt;= j &amp;&amp; nums[i] &lt; pivot) i++; //if(i&gt;j) break; while(i&lt;=j&amp;&amp; nums[j] &gt;= pivot) j--; //if(i&gt;j) break; if(i&lt;j) &#123; std::swap(nums[i],nums[j]); i++;j--;&#125; &#125; std::swap(nums[left],nums[j]); quick(nums, left, j-1); quick(nums,j+1,right); &#125; void sortColors(vector&lt;int&gt;&amp; nums) &#123; // 原地排序 // 相同颜色元素相邻，按照红白蓝顺序排列 // 这不就是一个排序吗， 0，1，2的顺序 // quick(nums,0,nums.size()-1); // 三指针法写一下 int p0 = 0 , p2 = nums.size()-1; int cur = 0; while(cur&lt;=p2)&#123; switch(nums[cur])&#123; case 0: std::swap(nums[cur],nums[p0]); p0++; cur++; break; case 2: std::swap(nums[cur],nums[p2]); p2--; break; case 1: cur++; &#125; &#125; &#125;&#125;; 上面把快排和三指针的写法放在一起了，三指针的想法就是用一个指针p0指向0的右边界，p2指向2的左边界，用cur指向当前元素， 根据cur值的不同做不同的操作，如果cur值为1,cur++,如果cur的值为2, 那么 swap(nums[cur],nums[p2]),p2—, 如果cur的值为0, swap(nums[cur],nums[p0]), cur++, p0++","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"矩阵置0","slug":"矩阵置0","date":"2020-01-26T18:26:55.000Z","updated":"2020-01-26T18:35:28.000Z","comments":true,"path":"2020/01/27/矩阵置0/","link":"","permalink":"http://yoursite.com/2020/01/27/矩阵置0/","excerpt":"","text":"前言这道题一开始想的是记录行数和列数,空间复杂度是O(m+n),但是要求要用常数空间,所以用矩阵的空间来记录哪一行那一列是置0的，我们用第一行和第一列来记录，这个想法也很神奇 代码class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; // 第一种，开一个 m*n 的空间 O(m*n) // 第二种记录哪些行，哪些列是有0 的， 空间复杂度是O(m+n) // 现在要我们想一个常数空间复杂度的方案.... // 那就是用原来的矩阵来记录哪些行和列是要置零的, 这个确实可以,不过没有想到 // 遍历到一个数，如果这个数是0,那么 int m = matrix.size(); if(m==0) return ; int n = matrix[0].size(); if(n==0) return; bool row= false, col = false; for(int i = 0 ;i&lt; m ;i++) if(matrix[i][0] == 0 )&#123;col =true;break;&#125; for(int j = 0 ;j &lt; n ;j++) if(matrix[0][j] ==0) &#123;row = true; break;&#125; // 如果是 for(int i = 1 ;i&lt;m;i++) for(int j = 1;j&lt;n;j++)&#123; if(matrix[i][j] == 0) &#123;matrix[i][0] =0; matrix[0][j]=0;&#125; &#125; for(int i = 1;i&lt;m;i++) for(int j = 1;j&lt;n;j++)&#123; if(matrix[i][0] ==0 || matrix[0][j] ==0 ) &#123;matrix[i][j] =0;&#125; &#125; if(col) for(int i = 0;i&lt;m;i++)&#123; matrix[i][0] =0;&#125; if(row) for(int j = 0;j&lt;n;j++)matrix[0][j] =0; &#125;&#125;; 就是一开始我们要确定一下第一行和第一列要不要置0,因为一旦用它作为记录以后，就不能确定第一行或者第一列中的元素0是本身还是因为同一个行的元素造成的，所以要提前记录一下, 这算法正确性的感性认识是，如果matrix[i][j]是0, matrix[i][0]和 matrix[0][j] 都是0, 如果本身不是0，因为这一行或者列有0，所以它最终还是要置0的， 如果本身是0，那就更加没事.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"133.克隆图","slug":"133-克隆图","date":"2020-01-26T11:59:21.000Z","updated":"2020-01-26T12:43:06.670Z","comments":true,"path":"2020/01/26/133-克隆图/","link":"","permalink":"http://yoursite.com/2020/01/26/133-克隆图/","excerpt":"","text":"前言这道题是中等题，但其实就是一个图的遍历问题 代码/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; neighbors; Node() &#123; val = 0; neighbors = vector&lt;Node*&gt;(); &#125; Node(int _val) &#123; val = _val; neighbors = vector&lt;Node*&gt;(); &#125; Node(int _val, vector&lt;Node*&gt; _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;;*/class Solution &#123;public: Node* cloneGraph(Node* node) &#123; // 图的深拷贝 if(!node)return NULL; if(used.find(node)!= used.end()) return used[node]; Node* new_node = new Node(node-&gt;val); used[node] = new_node; for(auto &amp;e : node-&gt;neighbors)&#123; //if(used.find(e)!= used.end()) &#123; new_node-&gt;neighbors.push_back(used[e]);continue;&#125; Node* temp = cloneGraph(e); new_node-&gt;neighbors.push_back(temp); &#125; return new_node; &#125; std::unordered_map&lt;Node*,Node*&gt; used;&#125;; 用的是dfs, 用一个map来保存旧图的节点到新图的节点的映射，来保证不会重复建立新节点.一旦一个节点被new出来就加入map, 这样再添加邻居的时候，就可以防止对同一个节点new多个新节点. 这道题也可以用bfs做.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"旋转数组","slug":"旋转数组","date":"2020-01-24T10:09:51.000Z","updated":"2020-01-24T10:20:58.435Z","comments":true,"path":"2020/01/24/旋转数组/","link":"","permalink":"http://yoursite.com/2020/01/24/旋转数组/","excerpt":"","text":"前言这道题是一道简单题,它的要求是原地，我一开始想到的是移动，每次移动一个数，但是会超时，后来想到反转 代码class Solution &#123;public: void helper(vector&lt;int&gt;&amp; nums, int left, int right)&#123; int i = left, j = right; while(i&lt;j)&#123; std::swap(nums[i],nums[j]); i++; j--; &#125; &#125; void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; // deque，模拟 // 原地 // 确定从哪个位置开始的元素需要搬运 k = k % nums.size(); if(k)&#123; int left_start =0, left_end = nums.size()-k-1; int right_start = nums.size()-k,right_end = nums.size()-1; helper(nums, left_start, left_end); helper(nums, right_start, right_end); helper(nums, 0, nums.size()-1); // while(k--)&#123; // int temp = nums[nums.size()-1]; // for(int j = nums.size()-2;j&gt;=0;j--)&#123; // nums[j+1] = nums[j]; // &#125; // nums[0] = temp; // &#125; &#125; &#125;&#125;; 这个思想还是比较巧妙的，三次逆序.原地，而且时间复杂度是O(n).","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"最大数","slug":"最大数","date":"2020-01-21T17:03:33.000Z","updated":"2020-01-21T17:14:31.931Z","comments":true,"path":"2020/01/22/最大数/","link":"","permalink":"http://yoursite.com/2020/01/22/最大数/","excerpt":"","text":"前言这道题其实本质是设计一个比较两个数“大小“的排序标准，也就是给定两个数，谁应该排在前面，使得作为字符串连接后数更大, 一开始没有想到其实只要排一下序就好，后来突然意识到就是设计排序标准，然后排序再依次连接就好，在写排序的时候也没有一开始就想到这样做，后来突然意识到就是字符串比较就行, a和b分开来比不好比，但是a+b 和 b+a 就很好比了 代码class Solution &#123;public: static bool helper(const string &amp; a , const string &amp; b) &#123; //string a_ = to_string(a); //string b_ = to_string(b); return a + b &gt; b + a; &#125; string largestNumber(vector&lt;int&gt;&amp; nums) &#123; // 返回字符串 //vector&lt;int&gt; ret; // int size = nums.size(); vector&lt;string&gt; strNums(nums.size()); std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) &#123; return std::to_string(x); &#125;); // 排序一下 ,直接得到答案 sort(strNums.begin(),strNums.end(),helper); string ret=\"\"; for(int i = 0 ; i &lt; strNums.size(); i++) ret += strNums[i]; //std::cout&lt;&lt;ret&lt;&lt;std::endl; int i = 0; while(ret[i] == '0')i++; if(i==0) return ret; if( i == ret.size()) return \"0\"; int num = ret.size()-i; ret = ret.substr(i,num); return ret; &#125;&#125;; 其实仔细想想，这道题貌似很简单…","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"连续值的分桶算法","slug":"连续值的分桶算法","date":"2020-01-20T08:39:06.000Z","updated":"2020-01-20T08:39:06.997Z","comments":true,"path":"2020/01/20/连续值的分桶算法/","link":"","permalink":"http://yoursite.com/2020/01/20/连续值的分桶算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"不同的二叉搜索数II","slug":"不同的二叉搜索数II","date":"2020-01-17T19:20:42.000Z","updated":"2020-01-17T19:29:24.582Z","comments":true,"path":"2020/01/18/不同的二叉搜索数II/","link":"","permalink":"http://yoursite.com/2020/01/18/不同的二叉搜索数II/","excerpt":"","text":"前言 这道题一开始就想到是递归，但是还是想了一会才想出来. 其实遍历每个树，把它当作树根，然后递归生成左子树和右子树，不过这里的左子树和右子树返回的不是一个指针，而是指针的数组，因为左子树和右子树都有可能有多种结构，这个看例子就可以看出来，所以对于左子树的可能的个数n和右子树的可能个数m，总共应该产生 n*m 个 根节点. 如果左子树为空，右子树n个可能，那么就产生n个根节点，对应不同的右子树，如果右子树为空，同理. 代码/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; helper(const std::vector&lt;int&gt;&amp; vec) &#123; if (vec.empty()) return &#123;&#125;; if(vec.size()==1)return &#123;new TreeNode(vec[0])&#125;; vector&lt;TreeNode*&gt; ret; for(int i = 0; i &lt; vec.size(); i++) &#123; std::vector&lt;int&gt; left(vec.begin(), vec.begin()+i); std::vector&lt;int&gt; right(vec.begin()+i+1, vec.end()); vector&lt;TreeNode*&gt; left_vec = helper(left); vector&lt;TreeNode*&gt; right_vec = helper(right); //vector&lt;TreeNode*&gt; temp_left; if (!left_vec.empty() &amp;&amp; !right_vec.empty() ) &#123; // for (auto&amp; e : left_vec)&#123; // TreeNode* root = new TreeNode(vec[i]); // root-&gt;left = e; // temp_left.push_back(root); // &#125; for(auto &amp; e : left_vec) for(auto&amp; j: right_vec) &#123; TreeNode* root = new TreeNode(vec[i]); root-&gt;left = e; root-&gt;right = j; ret.push_back(root); &#125; &#125; else if(!right_vec.empty()) &#123; for (auto&amp; e : right_vec)&#123; TreeNode *node = new TreeNode(vec[i]); node-&gt;right = e; ret.push_back(node); &#125; &#125; else if(!left_vec.empty()) &#123; for (auto&amp; e : left_vec)&#123; TreeNode *node = new TreeNode(vec[i]); node-&gt;left = e; ret.push_back(node); &#125; &#125; &#125; return ret; &#125; vector&lt;TreeNode*&gt; generateTrees(int n) &#123; // 二叉搜索树 //回溯法 std::vector&lt;int&gt; vec; for(int i =1;i&lt;=n;i++) vec.push_back(i); return helper(vec); &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"emplace","slug":"emplace","date":"2020-01-12T04:29:11.000Z","updated":"2020-01-12T08:15:11.065Z","comments":true,"path":"2020/01/12/emplace/","link":"","permalink":"http://yoursite.com/2020/01/12/emplace/","excerpt":"","text":"前言看lightgbm的代码遇到了 unordered_map 的 emplace 成员函数，之前并没有用过,所以查了一下用法，主要应该是在往哈希表里插入元素的时候，并没有 发生复制或者移动， 而是in place的构造了一个元素并插入. cppreference","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"全排列","slug":"全排列","date":"2020-01-12T03:49:09.000Z","updated":"2020-01-12T04:15:01.277Z","comments":true,"path":"2020/01/12/全排列/","link":"","permalink":"http://yoursite.com/2020/01/12/全排列/","excerpt":"","text":"前言看到这道题的第一个思路是遍历，就是确定第一个数，然后确定第二个数，这个算法其实就是回溯，用到递归. 但是实际执行效率很差. 代码class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return &#123;&#123;&#125;&#125; ; // 感觉可以用到我写random search 用到的方法 vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0 ; i&lt; nums.size();i++)&#123; //vector&lt;int&gt; tmp_res; //tmp_res.push_back(nums[i]); vector&lt;int&gt; tmp(nums.begin(), nums.begin()+i); for(int j = i+1; j&lt; nums.size();j++) tmp.push_back(nums[j]); auto e = permute(tmp); for(auto t: e )&#123; vector&lt;int&gt; tmp_res; tmp_res.push_back(nums[i]); for(int i = 0 ; i&lt;t.size(); i++)tmp_res.push_back(t[i]); res.push_back(tmp_res); &#125; &#125; return res; &#125;&#125;; 整体的思路是没错的，就是实现的时候太低效了,每次生成一个新的数组太低效了,通过交换来实现更高效，重新实现了一下class Solution &#123;public: void _backtrack(int start)&#123; if(start ==num-1 ) &#123; res.push_back(cop);return;&#125; for(int i = start; i&lt; num;i++)&#123; swap(cop[i],cop[start]); _backtrack(start+1); swap(cop[i], cop[start]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return &#123;&#123;&#125;&#125; ; num = nums.size(); cop = nums; //tmp = vector&lt;int&gt;(nums.size(),0); _backtrack(0); return res; &#125; // vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; res; int num; vector&lt;int&gt; cop;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"搜索旋转排序数组","slug":"搜索旋转排序数组","date":"2020-01-11T19:11:50.000Z","updated":"2020-01-15T05:00:58.290Z","comments":true,"path":"2020/01/12/搜索旋转排序数组/","link":"","permalink":"http://yoursite.com/2020/01/12/搜索旋转排序数组/","excerpt":"","text":"前言这道题出现的频率还是很高的 代码","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"搜索二维矩阵II","slug":"搜索二维矩阵II","date":"2020-01-11T18:52:57.000Z","updated":"2020-01-11T19:10:17.047Z","comments":true,"path":"2020/01/12/搜索二维矩阵II/","link":"","permalink":"http://yoursite.com/2020/01/12/搜索二维矩阵II/","excerpt":"","text":"前言拿到这题，我的第一个思路是二维的二分搜索，但其实是错的，给的例子就能看出为啥是错的 代码class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m==0)return false; int n = matrix[0].size(); if(n==0) return false; int row = 0 , col = n-1; while(row&lt;m&amp;&amp; col&gt;=0)&#123; if(matrix[row][col] == target) return true; if(matrix[row][col]&lt; target) row++; else col--; &#125; return false; &#125;&#125;; 上面的算法从矩阵右上角出发，只能向左或者向下,思路很巧妙。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"搜索二维矩阵","slug":"搜索二维矩阵","date":"2020-01-11T18:37:36.000Z","updated":"2020-01-11T18:52:02.384Z","comments":true,"path":"2020/01/12/搜索二维矩阵/","link":"","permalink":"http://yoursite.com/2020/01/12/搜索二维矩阵/","excerpt":"","text":"前言这题题目告诉了你是个二维矩阵，但其实就是个一维的排序矩阵， 那我们要找某个数，直接二分就好了 代码class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; //O(m*n)暴力 // 整体是有序的，直接用二分 int m = matrix.size(); if(m==0)return false; int n = matrix[0].size(); if(n==0) return false; int left = 0 , right= m*n -1; while(left&lt;right)&#123; int middle = (left+right)/2; int row = middle / n , col = middle% n; if(matrix[row][col]&gt;=target) right = middle; else left = middle +1; &#125; if(matrix[left/n][left%n] == target) return true; else return false; &#125;&#125;; 用之前用过的二分查找模板里面的其中一个就好了","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"盛最多水的容器","slug":"盛最多水的容器","date":"2020-01-11T08:28:02.000Z","updated":"2020-01-11T18:23:33.504Z","comments":true,"path":"2020/01/11/盛最多水的容器/","link":"","permalink":"http://yoursite.com/2020/01/11/盛最多水的容器/","excerpt":"","text":"前言这道题应该也是用双指针做,一个很暴力的做法就是两重循环,时间复杂度$O(n^{2})$,我们可以用双指针把时间复杂度优化到O(n). 思想其实用暴力法相当于把每一种可能的面积都遍历了一遍，但是其实有很多面积不遍历也是无所谓的，因为你确信他们的面积不会比当前已经获取到的最大面积更大了 代码class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int size = height.size(); int left = 0, right = size-1; int area = 0 ; while(left&lt;right)&#123; area = max(area, (right-left)*min(height[left],height[right])); if(height[left]&lt;height[right]) left++; else if (height[left]&gt;height[right]) right--; else &#123;left++;right--;&#125; &#125; return area; &#125;&#125;; 用两个指针left,right分别指向数组的开端和末尾，这时候我们获取到当前的面积，然后更新最大面积，下一步我们决定如何移动指针，我们的策略是移动较短的那条线段，因为我们是向中间移动， 所以宽度减小，而且高度取决于两个线段中较短的那一条，那么如果移动较长的那一条,如果新的线段变长了，没用，高度还是短的那一条，面积减小了，如果新的线段比短的还要短，面积更小了，所以移动长的那一条，无论如何面积都变小，所以我们移动短的那条，这样面积有可能增大，如果两个线段长度相等， 那么你只移动其中一个， 面积肯定变小，原理一样， 所以直接两个都移动.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"接雨水","slug":"接雨水","date":"2020-01-11T03:45:40.000Z","updated":"2020-01-11T14:10:50.943Z","comments":true,"path":"2020/01/11/接雨水/","link":"","permalink":"http://yoursite.com/2020/01/11/接雨水/","excerpt":"","text":"前言最近刷题季节， 这道题目考的概率很高 思想一个位置i的所能存储的水的最大高度是这样计算的：std::min( 从位置i向左的最大柱子高度 - 从位置i向右的最大柱子高度) - 位置i的柱子高度, 实现这个方法最简单的方法就是对于每一个位置都向左向右遍历了，时间复杂度是$O(n^{2})$的，可以进一步优化吗, 这种方法有大量的重复比较, 其实我们用两次遍历就可以得到一个位置向左和向右的最大柱子高度. 代码class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; // 每个位置， 只要找到两个方向上最高柱子中的较矮的那个-当前位置的柱子高度 int size = height.size(); std::vector&lt;int&gt; left(size,-1); std::vector&lt;int&gt; right(size,-1); int left_heightest = -1, right_heighst = -1; for(int i = 0 , j = size -1 ; i&lt; size &amp;&amp; j &gt;=0;i++,j--)&#123; if(i==0&amp;&amp;j==size-1)&#123; left_heightest = max(left_heightest,height[i]); right_heighst = max(right_heighst, height[j]); continue; &#125; if(left_heightest &gt; height[i] ) &#123; left[i] = left_heightest; &#125; else left_heightest = max(left_heightest,height[i]); if(right_heighst&gt;height[j])&#123; right[j] = right_heighst; &#125; else right_heighst = max(right_heighst,height[j]); &#125; int result=0; for(int i = 0 ;i&lt; size ;i++)&#123; if(left[i]!=-1 &amp;&amp; right[i] !=-1) result += (std::min(left[i],right[i]) - height[i]); &#125; return result; &#125;&#125;; 其实就是进行了两遍的遍历，然后 每个位置向左的最大高度和向右的最大高度全部求出来存储在两个数组里(虽然我代码里把两次遍历写在一起)， 最后再进行遍历，得到最后的结果. 上述的代码时间复杂度是O(n),空间复杂度也是O(n)的，是否还有进一步优化的空间呢? 双指针(优化空间复杂度)class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int result = 0 ; int size = height.size(); int left = 0 , right = size-1; int left_max = -1 , right_max = -1; while(left&lt;=right)&#123; left_max = max(left_max, height[left]); right_max = max(right_max,height[right]); if(left_max&lt;right_max) &#123; result+= left_max-height[left]; left++; &#125; else&#123; result += right_max-height[right]; right--; &#125; &#125; return result; &#125;&#125;; 在前面一种解法里，我们使用left和right数组分别记录位置i向左和向右的柱子的最大高度，在新的算法里， left_max和 right_max 分别记录的是left位置向左的柱子最大高度,right向右的最大高度柱子, 那么 我们如何确定left或者right位置的存水高度呢，其实对于一个位置的存水高度，我们是要求出这个位置向左向右的最大柱子高度的较小值，所以如果left_max&lt; right_max , 那么 left 位置的向右的最大柱子高度肯定是 &gt; left_max , 就算它计算的是right位置，那你遍历到left位置也肯定是大于的,所以这时候left位置的存水高度就可以确定了.同理 right_max &lt;= left_max 的时候, right位置的存水高度也可以确定了.现在这个算法空间复杂度是O(1)的.所以这个问题的最优时间复杂度和最优空间复杂度分别是O(n)和O(1). 参考接雨水","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"morris遍历","slug":"morris遍历","date":"2020-01-10T20:38:39.000Z","updated":"2020-01-10T20:38:39.995Z","comments":true,"path":"2020/01/11/morris遍历/","link":"","permalink":"http://yoursite.com/2020/01/11/morris遍历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"KMP","slug":"KMP","date":"2020-01-10T20:37:40.000Z","updated":"2020-01-10T20:45:28.185Z","comments":true,"path":"2020/01/11/KMP/","link":"","permalink":"http://yoursite.com/2020/01/11/KMP/","excerpt":"","text":"前言KMP是一个非常经典的字符串匹配算法，其实之前也有学习过，但是好久没用过，彻底给忘了，最近拿出来重新复习一下, 但是感觉面试的时候基本也是用不到的.好想也没看到过直接考这个的 算法思想例题","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2020-01-10T19:05:15.000Z","updated":"2020-01-10T19:21:55.930Z","comments":true,"path":"2020/01/11/拓扑排序/","link":"","permalink":"http://yoursite.com/2020/01/11/拓扑排序/","excerpt":"","text":"前言刷题的季节，熟悉一下以前学过的算法，拓扑排序，其实就是对一个有向无环图的顶点进行排序，得到一个线性的顺序， 在这个顺序中任意两个节点u,v,如果在原图中有u指向v的路径，那么u排在v的前面。 代码本科的时候学的就是入度的解法，这里给出的也是入度的解法，比较直观 class Solution &#123;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; std::unordered_map&lt;int,int&gt; ind; std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; mapp; std::queue&lt;int&gt; que; for(int i = 0; i&lt; numCourses;i++) ind[i] = 0; for(auto&amp; e : prerequisites)&#123; ind[e[0]] +=1; mapp[e[1]].push_back(e[0]); &#125; for(auto&amp; e : ind)&#123; if( e.second==0) &#123; que.push(e.first); &#125; &#125; int cnt = 0; while(que.size()&gt;0)&#123; cnt++; for(auto&amp; t : mapp[que.front()]) &#123;ind[t]--; if(ind[t]==0) que.push(t);&#125; que.pop(); &#125; if (cnt==numCourses) return true; else return false; &#125;&#125;; 代码的思路就是，我们首先用mapp记录这个图，每个节点会有它的邻接节点，每个节点会有一个入度，我们每次只要选取入度为0的节点就可以了，首先我们用一个队列将所有入度为0的节点加入队列，只要队列不为空，我们就从队列里面取出节点，每次一个节点被取出，它的邻居节点的入度就会减1，如果它的邻居节点的入度变为0，那么就将邻居节点加入队列，直到队列为空。 例题207 课程表210 课程表II","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"lightgbm/xgboost","slug":"lightgbm-xgboost","date":"2019-12-30T08:01:34.000Z","updated":"2019-12-30T09:40:32.620Z","comments":true,"path":"2019/12/30/lightgbm-xgboost/","link":"","permalink":"http://yoursite.com/2019/12/30/lightgbm-xgboost/","excerpt":"","text":"前言参考lightgbm","categories":[],"tags":[{"name":"gbdt","slug":"gbdt","permalink":"http://yoursite.com/tags/gbdt/"}]},{"title":"lightgbm源码解析1","slug":"lightgbm源码解析1","date":"2019-12-28T17:32:01.000Z","updated":"2019-12-29T04:01:48.223Z","comments":true,"path":"2019/12/29/lightgbm源码解析1/","link":"","permalink":"http://yoursite.com/2019/12/29/lightgbm源码解析1/","excerpt":"","text":"前言最近开始看lightgbm的源码，毕竟是个面试就会问的东西，核心代码是用c++写的，可以把它全看了,对实现ML算法会有很大的帮助 main.cpp#include &lt;LightGBM/application.h&gt;#include &lt;iostream&gt;#include \"network/linkers.h\"int main(int argc, char** argv) &#123; bool success = false; try &#123; LightGBM::Application app(argc, argv); // 定义了App类的对象，然后调用run app.Run();#ifdef USE_MPI LightGBM::Linkers::MpiFinalizeIfIsParallel();#endif success = true; &#125; catch (const std::exception&amp; ex) &#123; std::cerr &lt;&lt; \"Met Exceptions:\" &lt;&lt; std::endl; std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl; &#125; catch (const std::string&amp; ex) &#123; std::cerr &lt;&lt; \"Met Exceptions:\" &lt;&lt; std::endl; std::cerr &lt;&lt; ex &lt;&lt; std::endl; &#125; catch (...) &#123; std::cerr &lt;&lt; \"Unknown Exceptions\" &lt;&lt; std::endl; &#125; if (!success) &#123;#ifdef USE_MPI LightGBM::Linkers::MpiAbortIfIsParallel();#endif exit(-1); &#125;&#125; 可以看到main.cc真的相当简单. 下面我们来看看Application的代码: #ifndef LIGHTGBM_APPLICATION_H_#define LIGHTGBM_APPLICATION_H_#include &lt;LightGBM/config.h&gt;#include &lt;LightGBM/meta.h&gt;#include &lt;memory&gt;#include &lt;vector&gt;namespace LightGBM &#123;class DatasetLoader;class Dataset;class Boosting;class ObjectiveFunction;class Metric;/*!* \\brief The main entrance of LightGBM. this application has two tasks:* Train and Predict.* Train task will train a new model* Predict task will predict the scores of test data using existing model,* and save the score to disk.*/class Application &#123; public: Application(int argc, char** argv); /*! \\brief Destructor */ ~Application(); /*! \\brief To call this function to run application*/ inline void Run(); private: /*! \\brief Load parameters from command line and config file*/ void LoadParameters(int argc, char** argv); /*! \\brief Load data, including training data and validation data*/ void LoadData(); /*! \\brief Initialization before training*/ void InitTrain(); /*! \\brief Main Training logic */ void Train(); /*! \\brief Initializations before prediction */ void InitPredict(); /*! \\brief Main predicting logic */ void Predict(); /*! \\brief Main Convert model logic */ void ConvertModel(); /*! \\brief All configs */ Config config_; /*! \\brief Training data */ std::unique_ptr&lt;Dataset&gt; train_data_; /*! \\brief Validation data */ std::vector&lt;std::unique_ptr&lt;Dataset&gt;&gt; valid_datas_; /*! \\brief Metric for training data */ std::vector&lt;std::unique_ptr&lt;Metric&gt;&gt; train_metric_; /*! \\brief Metrics for validation data */ std::vector&lt;std::vector&lt;std::unique_ptr&lt;Metric&gt;&gt;&gt; valid_metrics_; /*! \\brief Boosting object */ std::unique_ptr&lt;Boosting&gt; boosting_; /*! \\brief Training objective function */ std::unique_ptr&lt;ObjectiveFunction&gt; objective_fun_;&#125;;inline void Application::Run() &#123; if (config_.task == TaskType::kPredict || config_.task == TaskType::KRefitTree) &#123; InitPredict(); Predict(); &#125; else if (config_.task == TaskType::kConvertModel) &#123; ConvertModel(); &#125; else &#123; InitTrain(); Train(); &#125;&#125;&#125; // namespace LightGBM#endif // LightGBM_APPLICATION_H_ 这类的声明也是相当的简单清晰了，说实话，之前一直知道lightgbm,是和xgboost差不多的gbdt,但是从来没看过源码，现在一看真的不是很相信居然这么的清晰.主要的run函数就是if…else代码块. Application::Application(int argc, char** argv) &#123;\\ LoadParameters(argc, argv); // set number of threads for openmp if (config_.num_threads &gt; 0) &#123; omp_set_num_threads(config_.num_threads); &#125; if (config_.data.size() == 0 &amp;&amp; config_.task != TaskType::kConvertModel) &#123; Log::Fatal(\"No training/prediction data, application quit\"); &#125; omp_set_nested(0);&#125; Application对象的构造函数，一开始先loadparameters,load以后config_对象就被这些参数填充了. void Application::LoadParameters(int argc, char** argv) &#123; std::unordered_map&lt;std::string, std::string&gt; params; // 从cmd line获取参数 for (int i = 1; i &lt; argc; ++i) &#123; Config::KV2Map(&amp;params, argv[i]); &#125; // check for alias ParameterAlias::KeyAliasTransform(&amp;params); // read parameters from config file if (params.count(\"config\") &gt; 0) &#123; TextReader&lt;size_t&gt; config_reader(params[\"config\"].c_str(), false); config_reader.ReadAllLines(); if (!config_reader.Lines().empty()) &#123; for (auto&amp; line : config_reader.Lines()) &#123; // remove str after \"#\" if (line.size() &gt; 0 &amp;&amp; std::string::npos != line.find_first_of(\"#\")) &#123; line.erase(line.find_first_of(\"#\")); &#125; line = Common::Trim(line); if (line.size() == 0) &#123; continue; &#125; Config::KV2Map(&amp;params, line.c_str()); &#125; &#125; else &#123; Log::Warning(\"Config file %s doesn't exist, will ignore\", params[\"config\"].c_str()); &#125; &#125; // check for alias again ParameterAlias::KeyAliasTransform(&amp;params); // load configs config_.Set(params); Log::Info(\"Finished loading parameters\");&#125; void Config::KV2Map(std::unordered_map&lt;std::string, std::string&gt;* params, const char* kv) &#123; // 一般cmd line 的形式都是 key=value std::vector&lt;std::string&gt; tmp_strs = Common::Split(kv, '='); if (tmp_strs.size() == 2 || tmp_strs.size() == 1) &#123; std::string key = Common::RemoveQuotationSymbol(Common::Trim(tmp_strs[0])); std::string value = \"\"; if (tmp_strs.size() == 2) &#123; value = Common::RemoveQuotationSymbol(Common::Trim(tmp_strs[1])); &#125; if (!Common::CheckASCII(key) || !Common::CheckASCII(value)) &#123; Log::Fatal(\"Do not support non-ASCII characters in config.\"); &#125; if (key.size() &gt; 0) &#123; auto value_search = params-&gt;find(key); if (value_search == params-&gt;end()) &#123; // not set params-&gt;emplace(key, value); &#125; else &#123; Log::Warning(\"%s is set=%s, %s=%s will be ignored. Current value: %s=%s\", key.c_str(), value_search-&gt;second.c_str(), key.c_str(), value.c_str(), key.c_str(), value_search-&gt;second.c_str()); &#125; &#125; &#125; else &#123; Log::Warning(\"Unknown parameter %s\", kv); &#125;&#125;","categories":[],"tags":[{"name":"gbdt","slug":"gbdt","permalink":"http://yoursite.com/tags/gbdt/"}]},{"title":"“滑动窗口”","slug":"“滑动窗口”","date":"2019-12-28T06:36:23.000Z","updated":"2019-12-28T06:36:23.568Z","comments":true,"path":"2019/12/28/“滑动窗口”/","link":"","permalink":"http://yoursite.com/2019/12/28/“滑动窗口”/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"vector<bool>","slug":"vector-bool","date":"2019-12-28T05:03:15.000Z","updated":"2019-12-28T09:59:10.904Z","comments":true,"path":"2019/12/28/vector-bool/","link":"","permalink":"http://yoursite.com/2019/12/28/vector-bool/","excerpt":"","text":"前言去第四范式面试实习，被问了这么一个题，vector&lt;bool&gt; a(10000),占用多少内存，首先一开始问的是vector&lt;int&gt; a(10000)占用多少内存，其实一开始我是有点意外的，因为对STL内部实现的机制并不是很熟，这块这个寒假要补上来,但是想一个int就占4个字节，10000个不就是40000个字节，STL内部应该不会再怎么压缩存储吧，就说是40000个字节，然后面试官就说嗯，我想应该是对的，然后就给出了前面的那个问题，vector&lt;bool&gt;占多少内存呢，其实我一开始说bool值用一位表示就可以了，但是想到c++中的bool类型，我突然犹豫了，因为细细回想，我还真没有注意过bool类型占多少个字节，平时写c++程序，也不会对bool类型的变量取sizeof,一般需要一个判断条件的时候声明一个bool变量，而且bool变量在c++里面打印出来都是0，1，至于具体的字节数还真没有留意过。 实践#include &lt;iostream&gt;int main()&#123;bool a=true;std::cout&lt;&lt; sizeof(a) &lt;&lt;std::endl;bool* p = &amp;a;std::cout&lt;&lt;*p&lt;&lt;std::endl;return 0;&#125; 可以看到bool类型占一个字节，然后还有指向bool类型的指针，不过到目前为止，我还没有写过指向bool类型的指针，真的也是很垃圾了. 那vector&lt;bool&gt; a(10000)是不是就占了10000个字节了，不敢确定，因为我心里一直想的是bool类型用一位就可以表示，STL会不会做优化呢，感觉不做太浪费内存了把.我们继续来确定一下这件事情. #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template&lt;typename T&gt;void func(vector&lt;T&gt;&amp; v)&#123; T&amp; ref = v[0];&#125;int main()&#123;std::vector&lt;bool&gt; a_;a_.push_back(true);a_.push_back(false);func(a_);return 0;&#125; 结果如下，可以看到编译出错，不过错误信息和参考中的有点不太一样. 不过可以看到大概是 std::_Bit_reference数据结构，然后定义了到bool类型的转换，然后变成了bool类型的右值，然后赋值给了非const的引用.所以引发了错误. (base) root@f3aecd5d6b8f:~# g++ test.cc -o testtest.cc: In instantiation of 'void func(std::vector&lt;T&gt;&amp;) [with T = bool]':test.cc:28:8: required from heretest.cc:6:14: error: invalid initialization of non-const reference of type 'bool&amp;' from an rvalue of type 'bool' T&amp; ref = v[0]; ^In file included from /usr/include/c++/5/vector:65:0, from test.cc:2:/usr/include/c++/5/bits/stl_bvector.h:80:5: note: after user-defined conversion: std::_Bit_reference::operator bool() const operator bool() const _GLIBCXX_NOEXCEPT 所以vector内部的存储确实不是按照一个字节来的，是按照位来的.但是目前知道是一个std::_Bit_reference类型. 参考vector","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"最近公共祖先","slug":"最近公共祖先","date":"2019-12-24T08:16:22.000Z","updated":"2020-02-01T17:29:01.945Z","comments":true,"path":"2019/12/24/最近公共祖先/","link":"","permalink":"http://yoursite.com/2019/12/24/最近公共祖先/","excerpt":"","text":"前言最近公共祖先的题目可以分为二叉搜索树，二叉树，多叉树.下面分别针对这些不同的树类型给出对应的解法 二叉搜索树二叉树多叉树","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"dijkstra复习","slug":"dijkstra复习","date":"2019-12-24T08:10:15.000Z","updated":"2019-12-24T08:15:46.030Z","comments":true,"path":"2019/12/24/dijkstra复习/","link":"","permalink":"http://yoursite.com/2019/12/24/dijkstra复习/","excerpt":"","text":"题目1129. 颜色交替的最短路径 代码: class Solution &#123;public: vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; red_edges, vector&lt;vector&lt;int&gt;&gt;&amp; blue_edges) &#123; vector&lt;vector&lt;int&gt;&gt; graph(n,vector&lt;int&gt;(n,0x3f3f3f3f)); vector&lt;vector&lt;int&gt;&gt; color(n,vector&lt;int&gt;(n,-1)); // for(auto &amp; e: red_edges)&#123; graph[e[0]][e[1]] = 1; color[e[0]][e[1]] = 0;&#125; for(auto &amp; e: blue_edges)&#123; graph[e[0]][e[1]] = 1; if(color[e[0]][e[1]]==0)color[e[0]][e[1]] = 2; else color[e[0]][e[1]] = 1; &#125; // 一个方向的边可能既有蓝色又有红色 // read , blue // vector&lt;int&gt; res(n,-1); // 选择路径的时候加上边的颜色的限制 vector&lt;vector&lt;int&gt;&gt; min_len(2,vector&lt;int&gt;(n,0x3f3f3f3f)); min_len[0][0]=0; min_len[1][0]=0; vector&lt;vector&lt;int&gt;&gt; used(2,vector&lt;int&gt;(n,0)); // 0 means not used,1 means used // vector&lt;int&gt; last_col(n,-1) ; // -1 means start , 0 means red , 1 means blue ///////// int p = 2*n; while(p--)&#123; int red_chosen; int blue_chosen; int red_max_ = 0x3f3f3f3f; // infinite int blue_max_ = 0x3f3f3f3f; for(int i = 0 ;i &lt; n; i++ ) &#123; if(!used[0][i]&amp;&amp; min_len[0][i]&lt;red_max_ ) &#123; red_max_ = min_len[0][i]; red_chosen= i;&#125; if(!used[1][i]&amp;&amp; min_len[1][i]&lt;blue_max_ ) &#123; blue_max_ = min_len[1][i]; blue_chosen= i;&#125; &#125; if(red_max_==0x3f3f3f3f &amp;&amp; blue_max_==0x3f3f3f3f) break; if(red_max_!=0x3f3f3f3f)&#123; used[0][red_chosen] = 1; for(int i = 0;i&lt;n;i++)&#123; // 更新路径距离 if(!used[1][i] &amp;&amp; color[red_chosen][i] != 0 ) &#123; // 1 or 2 if(min_len[1][i]&gt; min_len[0][red_chosen]+ graph[red_chosen][i])&#123; //last_col[i] = 1- last_col[chosen]; min_len[1][i] = std::min(min_len[1][i], min_len[0][red_chosen]+graph[red_chosen][i]); &#125; &#125; &#125; &#125; if(blue_max_!=0x3f3f3f3f)&#123; used[1][blue_chosen] = 1; for(int i = 0;i&lt;n;i++)&#123; // 更新路径距离 if(!used[0][i] &amp;&amp; color[blue_chosen][i] != 1 ) &#123; // 1 or 2 if(min_len[0][i]&gt; min_len[1][blue_chosen]+ graph[blue_chosen][i])&#123; //last_col[i] = 1- last_col[chosen]; min_len[0][i] = std::min(min_len[0][i], min_len[1][blue_chosen]+graph[blue_chosen][i]); &#125; &#125; &#125; &#125; &#125; vector&lt;int&gt; res(n,0x3f3f3f3f); for(int i = 0 ;i&lt; n; i++ )&#123; if(min_len[0][i]==0x3f3f3f3f &amp;&amp; min_len[1][i]==0x3f3f3f3f) res[i]=-1; else res[i] = std::min(min_len[0][i],min_len[1][i]); &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"读者写者模型","slug":"读者写者模型","date":"2019-12-23T19:38:45.000Z","updated":"2019-12-24T18:44:12.420Z","comments":true,"path":"2019/12/24/读者写者模型/","link":"","permalink":"http://yoursite.com/2019/12/24/读者写者模型/","excerpt":"","text":"前言读者写者问题是另一个经典的线程同步问题. 问题一个数据由多个线程共享，这些线程分为两类，一类是读者线程，一类是写者线程。读者线程只读数据，不修改数据，写者线程会修改数据。读读不互斥，写和读，写和写都互斥，也就是只要有一个写线程，其他线程就不能访问数据. 读者优先实现mutext = 1wrt = semaphore(1)readcount =0 读者： do&#123;p(mutex)readcount++if(readcount==1) p(wrt)v(mutex)readp(mutext)readcount--if(readcount==0) v(wrt)v(mutex)&#125;while(true) 写者：do&#123;p(wrt)writev(wrt)&#125;while(true) 仔细分析，上面的程序，只要有一个写者，其他线程就不能访问数据，一旦有一个读者获取wrt从而访问数据，其他的读者就能能够一起访问数据。可以看出上面的程序是读者优先的，一旦有一个读者获取到wrt，其他读者就能够源源不断的访问数据，从而饿死写者. 写者优先实现写者优先的话，一旦有一个写进程来，就阻塞后续的读进程，需要增加一个writercount,一个信号量r，以及一个互斥量mutexwriter来更新writercount 写者: do&#123;p(mutexwriter) writercount++ if(writercount==1) p(r)v(mutexwriter)p(w)writev(w)p(mutexwriter) writercount--; if(writercount==0) v(r)v(mutexwriter)&#125;while(true) 读进程 p(r) p(mutexreader) readcount++ if(readcount==1)p(w) v(mutexreader)v(r)readp(mutexreader) readcount-- if(readcount==0)v(w)v(mutexreader)","categories":[],"tags":[{"name":"operating system","slug":"operating-system","permalink":"http://yoursite.com/tags/operating-system/"}]},{"title":"零拷贝","slug":"零拷贝","date":"2019-12-23T16:16:14.000Z","updated":"2020-01-17T19:20:21.433Z","comments":true,"path":"2019/12/24/零拷贝/","link":"","permalink":"http://yoursite.com/2019/12/24/零拷贝/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"IPC(进程间通信)","slug":"IPC-进程间通信","date":"2019-12-23T14:21:14.000Z","updated":"2019-12-23T14:21:14.660Z","comments":true,"path":"2019/12/23/IPC-进程间通信/","link":"","permalink":"http://yoursite.com/2019/12/23/IPC-进程间通信/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"select/poll/epoll","slug":"select-poll-epoll","date":"2019-12-23T14:19:47.000Z","updated":"2020-07-22T03:46:33.769Z","comments":true,"path":"2019/12/23/select-poll-epoll/","link":"","permalink":"http://yoursite.com/2019/12/23/select-poll-epoll/","excerpt":"","text":"前言select/poll/epoll的区别是面试中问得最多的考点了，在腾讯的面试中就出现了。同理还有阻塞io/非阻塞io,同步io,异步io等等.下面就用代码来详细了解一下select, poll, epoll的区别 select","categories":[],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"}]},{"title":"双指针","slug":"双指针","date":"2019-12-23T14:15:52.000Z","updated":"2019-12-23T14:15:52.856Z","comments":true,"path":"2019/12/23/双指针/","link":"","permalink":"http://yoursite.com/2019/12/23/双指针/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二分法的两种写法","slug":"二分法的两种写法","date":"2019-12-23T14:05:36.000Z","updated":"2019-12-23T14:24:22.300Z","comments":true,"path":"2019/12/23/二分法的两种写法/","link":"","permalink":"http://yoursite.com/2019/12/23/二分法的两种写法/","excerpt":"","text":"在一个排序数组nums中找&lt;=target的最大的数while(l&lt;r)&#123;int middle = (l+r+1)/2;if(nums[middle]&lt;=target)l =middle ; else r = middle -1;&#125;return nums[l]; 在一个排序数组nums中找&gt;=x的最小的数while(l&lt;r)&#123;int middle = (l+r)/2;if(nums[middle]&gt;=x) r = middle; else l = middle + 1;&#125;return nums[l]; 以上两种写法能保证循环退出时，l==r, 来自于算法竞赛进阶指南. leetcode例题34. 在排序数组中查找元素的第一个和最后一个位置 很直接的用两种二分法各求一遍，得到答案. 代码如下: lass Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()==0)return &#123;-1,-1&#125;; // O(logn) 二分 int l = 0 , r = nums.size()-1; int left = -1, right =-1; while(l&lt;r)&#123; int mid =(l+r)/2; if(nums[mid]&gt;=target) r = mid; else l = mid +1; &#125; if(nums[l]==target)left = l; l = 0, r = nums.size()-1; // while(l&lt;r)&#123; // int mid =(l+r)/2; // if(nums[mid]&gt;target) r = mid-1; else l = mid +1; // &#125; // right = l-1; // left =l; while(l&lt;r)&#123; int mid =(l+r+1)/2; if(nums[mid]&lt;=target) l = mid; else r = mid -1; &#125; if(nums[l]==target)right = l; return &#123;left,right&#125;; &#125;&#125;;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"蓄水池抽样","slug":"蓄水池抽样","date":"2019-12-23T09:46:25.000Z","updated":"2019-12-23T12:42:35.945Z","comments":true,"path":"2019/12/23/蓄水池抽样/","link":"","permalink":"http://yoursite.com/2019/12/23/蓄水池抽样/","excerpt":"","text":"问题从n条数据中，随机抽取k条数据，要求每条数据被抽取到的概率相等即$ \\frac{k}{n} $. 算法伪代码Init : a reservoir with the size： k for i= k+1 to N M=random(1, i); if( M &lt; k) SWAP the Mth value and ith value end for 首先直接用前k条数据初始化一个size为k的蓄水池.然后对从k+1到N的数据进行遍历，对于第i条数据，它有 $ \\frac{k}{i}$的概率被选中，然后以 $\\frac{1}{k}$的概率替换掉蓄水池中的任意一条数据. 证明我们来证明一下，这个算法使得每条数据被选中的概率是相等的。 对于第k+1条数据，它被选中的概率是$\\frac{k}{k+1}$,对于前k条数据，被选中的概率是1-被第k+1条数据替换的概率= $ 1- \\frac{k}{k+1}\\cdot\\frac{1}{k} = \\frac{k}{k+1}$. 假设前i条数据，每条被选中的概率是 $\\frac{k}{i}$ . 那么前i+1条数据，对于第i+1条数据，被选中的概率是$\\frac{k}{i+1}$, 前i条数据每条被选中的概率是前i次被选中概率乘以(1-被第i+1条数据替换的概率)，也就是$\\frac{k}{i}\\cdot\\left(1-\\frac{k}{i+1}\\cdot\\frac{1}{k}\\right) = \\frac{k}{i+1} $. 所以前i+1条数据，每条被选中的概率是$\\frac{k}{i+1}$. leetcode例题leetcode中有很多题涉及到蓄水池抽样问题.比如第382题链表随机节点 题目： 给定一个不知道长度的单链表，让我们随机返回其中一个节点的值，保证每个节点被采样的概率相等。这赤裸裸的蓄水池抽样，k为1. 代码如下： /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* head) &#123; this-&gt;head = head; &#125; /** Returns a random node's value. */ int getRandom() &#123; int cnt = 0; int chosen; ListNode* p = this-&gt;head; while(p)&#123; cnt++; int rank = rand()%cnt; if(rank&lt;1) chosen = p-&gt;val; p=p-&gt;next; &#125; return chosen; &#125; ListNode* head;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(head); * int param_1 = obj-&gt;getRandom(); */ 从相似题目中还可以找到398. 随机数索引 题目： 给定一个数组里可能有重复的数，搜索数组，返回给定数的下标，如果给定数在数组中有多个的话，返回每个下标的概率相等 其实就是变了一下，在所有等于给定数的数中选取一个，返回下标，那么我们遍历，如果当前数等于给定数，我们把cnt++. 代码如下：class Solution &#123;public: Solution(vector&lt;int&gt;&amp; nums):nums(nums) &#123; &#125; int pick(int target) &#123; int cnt = 0 ; int res= 0 ; for(int i = 0;i&lt;nums.size();i++)&#123; if(nums[i]==target)&#123; cnt++; int index =rand()%cnt; if(index&lt;1)res = i; &#125; &#125; return res; &#125; vector&lt;int&gt;&amp; nums;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * int param_1 = obj-&gt;pick(target);","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"zeromq(1)","slug":"zeromq-1","date":"2019-12-19T15:07:15.000Z","updated":"2019-12-19T17:24:48.003Z","comments":true,"path":"2019/12/19/zeromq-1/","link":"","permalink":"http://yoursite.com/2019/12/19/zeromq-1/","excerpt":"","text":"前言在ps-lite中使用了zeromq作为通信库，因此来学习一下zeromq,看了资料收虽然zeromq叫mq,但是并不传统意义山的消息队列，更像是一个网络通信库。 参考:ZeroMQ基础","categories":[],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"}]},{"title":"哲学家就餐问题","slug":"哲学家就餐问题","date":"2019-12-08T04:26:45.000Z","updated":"2019-12-24T07:48:59.865Z","comments":true,"path":"2019/12/08/哲学家就餐问题/","link":"","permalink":"http://yoursite.com/2019/12/08/哲学家就餐问题/","excerpt":"","text":"前言哲学家就餐问题是经典的线程同步问题。 问题有5个哲学家围坐在一个圆桌上，桌上有5盘食物，5个叉子，如下图所示:哲学家就餐或者思考，就餐时哲学家会拿起左右手的两个叉子，只有当两个叉子都拿到时，哲学家才能进行就餐，在没有拿到所有叉子前，不会放下手中的叉子. 可能死锁的实现semaphore forks[5]=&#123;1,1,1,1,1&#125;;for philosopher i: do&#123; p(forks[i]); p(forks[(i+1)%5]); 就餐 v(forks[i]); v(forks[(i+1)%5]); &#125;while(true) 当所有的哲学家同时拿起左手边的叉子的时候，系统就死锁了，他们都拿不到右手边的叉子，但是又不放下左手边的叉子，最后都饿死了. 解决方案我们总结下导致死锁的原因和四个必要条件:","categories":[],"tags":[{"name":"operating system","slug":"operating-system","permalink":"http://yoursite.com/tags/operating-system/"}]},{"title":"c++进程同步和线程同步","slug":"c-进程同步和线程同步","date":"2019-12-08T03:55:29.000Z","updated":"2019-12-08T03:55:29.567Z","comments":true,"path":"2019/12/08/c-进程同步和线程同步/","link":"","permalink":"http://yoursite.com/2019/12/08/c-进程同步和线程同步/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"petuum的ssp实现流程","slug":"petuum的ssp实现流程","date":"2019-12-08T03:08:01.000Z","updated":"2019-12-08T03:08:01.094Z","comments":true,"path":"2019/12/08/petuum的ssp实现流程/","link":"","permalink":"http://yoursite.com/2019/12/08/petuum的ssp实现流程/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"psAllreduce","slug":"psAllreduce","date":"2019-12-07T15:59:57.000Z","updated":"2019-12-07T16:02:19.065Z","comments":true,"path":"2019/12/07/psAllreduce/","link":"","permalink":"http://yoursite.com/2019/12/07/psAllreduce/","excerpt":"","text":"前言最近一直对ps-lite增加功能, 这段时间准备借鉴petuum的方式增加ssp,以后功能越来越全以后，和nccl结合搞一个混合的数据并行的框架。","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"petuum/paracel/Angel/ps-lite/byteps","slug":"petuum-paracel-Angel-ps-lite-byteps","date":"2019-12-06T15:48:39.000Z","updated":"2019-12-06T15:48:39.634Z","comments":true,"path":"2019/12/06/petuum-paracel-Angel-ps-lite-byteps/","link":"","permalink":"http://yoursite.com/2019/12/06/petuum-paracel-Angel-ps-lite-byteps/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"库函数与系统调用的区别","slug":"库函数与系统调用的区别","date":"2019-12-06T08:00:34.000Z","updated":"2019-12-06T08:00:34.614Z","comments":true,"path":"2019/12/06/库函数与系统调用的区别/","link":"","permalink":"http://yoursite.com/2019/12/06/库函数与系统调用的区别/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多继承与虚基类","slug":"多继承与虚基类","date":"2019-12-06T07:28:21.000Z","updated":"2019-12-19T15:03:52.478Z","comments":true,"path":"2019/12/06/多继承与虚基类/","link":"","permalink":"http://yoursite.com/2019/12/06/多继承与虚基类/","excerpt":"","text":"前言c++ 支持多继承，多继承会带来一些问题，比如典型的菱形继承中，会出现最开始的基类在派生类对象中存在两份拷贝的问题，也就会出现二义性。为了消除这种二义性，我们可以使用虚继承，使得基类在派生类中只有一份拷贝。而c++的虚继承的实现方式一般是用一个指针指向虚基类表，但是在最新的g++编译器中，已经把虚表指针和虚基类表指针给合并了，本来这些都是编译器的具体实现，而c++规范中并没有明确具体的实现方式。 菱形继承菱形继承如下图所示，v代表B,C虚继承A,A是虚基类： /****************************//* *//* A *//* v/ \\v *//* / \\ *//* B C *//* \\ / *//* \\ / *//* D *//* *//****************************/ 虚继承的的对象内存布局具体见参考,g++的实现是将虚基类放在派生类对象的底部。 测试#include&lt;iostream&gt;struct A&#123; int ax; virtual void f0() &#123;&#125; virtual void bar() &#123; std::cout&lt;&lt;\"A: bar()\"&lt;&lt;std::endl;&#125;&#125;;struct B : virtual public A /****************************/&#123; /* */ int bx; B()&#123; bx=5;&#125; /* A */ void f0() override &#123;&#125; /* v/ \\v */&#125;; /* / \\ */ /* B C */struct C : virtual public A /* \\ / */&#123; /* \\ / */ int cx; C()&#123;cx=8;&#125; /* D */ void f0() override &#123;&#125; /* */&#125;; /****************************/struct D : public B, public C&#123; int dx; D()&#123;dx=6;&#125; void f0() override &#123; std::cout&lt;&lt; 9 &lt;&lt; std::endl;&#125;&#125;;typedef void(*func)();int main()&#123;D d;long* p = (long*)&amp;d;long address = *p;func q =(func)(*(long*)address);q();p++;int t = (*(int*)p);std::cout&lt;&lt;t&lt;&lt;std::endl;int* u = (int*)p;u+=2;q = (func)( *(long*) (*(long*)u) );q();long* y = (long*)u;y++;u = (int*)y;std::cout&lt;&lt;*u&lt;&lt;std::endl;u+=1;std::cout&lt;&lt;*u&lt;&lt;std::endl;u+=1;q = (func)( *((long*) (*((long*)u))+1) );q();&#125; 上面的测试代码中u+=2是处于内存对齐的考虑. 参考c++虚继承和虚基类","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"unordered_map实现","slug":"unordered-map实现","date":"2019-12-05T06:18:30.000Z","updated":"2019-12-05T06:18:30.978Z","comments":true,"path":"2019/12/05/unordered-map实现/","link":"","permalink":"http://yoursite.com/2019/12/05/unordered-map实现/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"weak_ptr实现","slug":"weak-ptr实现","date":"2019-12-05T06:17:55.000Z","updated":"2019-12-05T07:27:30.233Z","comments":true,"path":"2019/12/05/weak-ptr实现/","link":"","permalink":"http://yoursite.com/2019/12/05/weak-ptr实现/","excerpt":"","text":"前言weak_ptr是为了解决shared_ptr存在的循环引用问题而诞生的。它依赖于shared_ptr,不能直接管理一块动态开辟的空间。不具备普通指针的行为operator*和operator-&gt;。构造weak_ptr不会引起引用计数的变化。 循环引用问题代码见smart pointer中的crossRef.cc。 weak_ptr实现参考weak_ptr源码分析","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c++模板类的分离式编译","slug":"c-模板类的分离式编译","date":"2019-12-05T02:50:45.000Z","updated":"2019-12-05T04:54:25.724Z","comments":true,"path":"2019/12/05/c-模板类的分离式编译/","link":"","permalink":"http://yoursite.com/2019/12/05/c-模板类的分离式编译/","excerpt":"","text":"前言在实现自己的shared_ptr的时候，习惯性的将模板类的接口和实现分别放在对应的.h文件和.cc文件中，然后在test.cc文件中包含.h头文件，进行测试，结果总是报undefinend reference的错误，一开始感觉很奇怪，我明明在编译的时候将模板类的.cc文件给包含进来了，可是居然在链接的时候找不到。最后查到了原因。原来编译器对模板类的分离式编译支持的非常差，比如STL的代码中都是将模板类的接口和实现放在一起的。虽然有可以分离编译的方法，但是主流还是将接口和实现放在同一个.h文件中，简单而且跨平台兼容。 之所以分离式编译的时候出现问题，是因为我们的模板类的.cc文件中只include模板类的.h文件，然后也没有对具体typename类型的调用(没有调用所以没有隐式实例化)，所以编译成的模板类的.o文件中是没有具体实例化的模板类的代码的，所以链接的时候找不到实例化类的代码。 分离式编译[1]DSharedPtr.h #include &lt;unordered_map&gt;#include &lt;iostream&gt;template&lt;typename T&gt;class DSharedPtr&#123;private:T * _ptr;static std::unordered_map&lt;T*,int&gt; _cnt;public:DSharedPtr(T* ptr=nullptr);~DSharedPtr();DSharedPtr(DSharedPtr&lt;T&gt;&amp; src);DSharedPtr&amp; operator=(DSharedPtr&lt;T&gt;&amp; src);T&amp; operator*();T* operator-&gt;();&#125;; [2]DSharedPtr.cc#include \"./DSharedPtr.h\"template&lt;typename T&gt;std::unordered_map&lt;T*,int&gt; DSharedPtr&lt;T&gt;::_cnt;template&lt;typename T&gt;DSharedPtr&lt;T&gt;::DSharedPtr(T* ptr)&#123; _ptr = ptr;if(_cnt.count(ptr)==0)_cnt[ptr] = 1;else _cnt[ptr]+=1;&#125;template&lt;typename T&gt;DSharedPtr&lt;T&gt;::~DSharedPtr()&#123;--_cnt[_ptr];if(_cnt[_ptr]&lt;=0) &#123;_cnt.erase(_ptr);delete _ptr; // delete nullptr is ok &#125;&#125;template&lt;typename T&gt;DSharedPtr&lt;T&gt;::DSharedPtr(DSharedPtr&lt;T&gt;&amp; src)&#123;_ptr = src._ptr;_cnt[_ptr]+=1;&#125;template&lt;typename T&gt;DSharedPtr&lt;T&gt;&amp; DSharedPtr&lt;T&gt;::operator=(DSharedPtr&lt;T&gt;&amp; src)&#123;if(_ptr==src._ptr) return *this;--_cnt[_ptr];if (_cnt[_ptr]&lt;=0)&#123;_cnt.erase(_ptr);delete _ptr;&#125;_ptr = src._ptr;_cnt[_ptr]+=1;return *this;&#125;template&lt;typename T&gt;T&amp; DSharedPtr&lt;T&gt;::operator*()&#123;return *_ptr;&#125;//why template&lt;typename T&gt;T* DSharedPtr&lt;T&gt;::operator-&gt;()&#123;return _ptr;&#125;templateclass DSharedPtr&lt;int&gt;; // 类模板的显示实例化 [3]test.cc#include \"./DSharedPtr.h\"#include &lt;iostream&gt;using namespace std;int main()&#123;int *p = new int(10);DSharedPtr&lt;int&gt; mshared_p1(p);DSharedPtr&lt;int&gt; mshared_p2(new int(20));cout &lt;&lt; *mshared_p1 &lt;&lt; endl;cout &lt;&lt; *mshared_p2 &lt;&lt; endl;return 0;&#125; 因为有类模板的显示实例化，所以上面的程序可以编译运行。 将接口和实现放在同一个.h文件中不过最主流的做法还是将模板类的接口和实现放在同一个.h文件中,如下: [1]DSharedPtr.h #include &lt;unordered_map&gt;#include &lt;iostream&gt;template&lt;typename T&gt;class DSharedPtr&#123;private:T * _ptr;static std::unordered_map&lt;T*,int&gt; _cnt;public:DSharedPtr(T* ptr=nullptr);~DSharedPtr();DSharedPtr(DSharedPtr&lt;T&gt;&amp; src);DSharedPtr&amp; operator=(DSharedPtr&lt;T&gt;&amp; src);T&amp; operator*();T* operator-&gt;();&#125;;emplate&lt;typename T&gt;std::unordered_map&lt;T*,int&gt; DSharedPtr&lt;T&gt;::_cnt;template&lt;typename T&gt;DSharedPtr&lt;T&gt;::DSharedPtr(T* ptr)&#123; _ptr = ptr;if(_cnt.count(ptr)==0)_cnt[ptr] = 1;else _cnt[ptr]+=1;&#125;template&lt;typename T&gt;DSharedPtr&lt;T&gt;::~DSharedPtr()&#123;--_cnt[_ptr];if(_cnt[_ptr]&lt;=0) &#123;_cnt.erase(_ptr);delete _ptr; // delete nullptr is ok &#125;&#125;template&lt;typename T&gt;DSharedPtr&lt;T&gt;::DSharedPtr(DSharedPtr&lt;T&gt;&amp; src)&#123;_ptr = src._ptr;_cnt[_ptr]+=1;&#125;template&lt;typename T&gt;DSharedPtr&lt;T&gt;&amp; DSharedPtr&lt;T&gt;::operator=(DSharedPtr&lt;T&gt;&amp; src)&#123;if(_ptr==src._ptr) return *this;--_cnt[_ptr];if (_cnt[_ptr]&lt;=0)&#123;_cnt.erase(_ptr);delete _ptr;&#125;_ptr = src._ptr;_cnt[_ptr]+=1;return *this;&#125;template&lt;typename T&gt;T&amp; DSharedPtr&lt;T&gt;::operator*()&#123;return *_ptr;&#125;//why template&lt;typename T&gt;T* DSharedPtr&lt;T&gt;::operator-&gt;()&#123;return _ptr;&#125; 这样就不用类模板的显示实例化。上面的shared_ptr代码需要进一步改进，来支持多线程下的线程安全以及存在循环引用的问题。进一步改进的代码会在中smart pointer进行更新。 参考c++模板类的分离式编译","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"new与malloc的区别","slug":"new与malloc的区别","date":"2019-12-04T09:41:16.000Z","updated":"2019-12-04T09:41:16.275Z","comments":true,"path":"2019/12/04/new与malloc的区别/","link":"","permalink":"http://yoursite.com/2019/12/04/new与malloc的区别/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"shared_ptr实现","slug":"shared-ptr实现","date":"2019-12-04T09:40:59.000Z","updated":"2019-12-04T10:04:04.083Z","comments":true,"path":"2019/12/04/shared-ptr实现/","link":"","permalink":"http://yoursite.com/2019/12/04/shared-ptr实现/","excerpt":"","text":"前言c++面试经常会问到智能指针，我们来实现一下shared_ptr，探究一下智能指针的原理。shared_ptr的核心就是【引用计数】的实现，还有shared_ptr貌似在多线程的环境下是有问题的。智能指针主要是用来解决原生指针可能造成的问题，比如忘记手动释放内存造成内存泄漏等等。 参考","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"多个进程调用同一个.so文件","slug":"多个进程调用同一个-so文件","date":"2019-12-04T07:23:57.000Z","updated":"2019-12-04T07:23:57.029Z","comments":true,"path":"2019/12/04/多个进程调用同一个-so文件/","link":"","permalink":"http://yoursite.com/2019/12/04/多个进程调用同一个-so文件/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"vtable","slug":"vtable","date":"2019-12-04T04:31:22.000Z","updated":"2019-12-04T06:37:10.520Z","comments":true,"path":"2019/12/04/vtable/","link":"","permalink":"http://yoursite.com/2019/12/04/vtable/","excerpt":"","text":"前言我们知道c++的运行时动态是由虚函数来实现的,而虚函数的实现方式不同编译器不同，一个比较典型的实现方式就是使用vtable,vtabl中存储的是每个虚函数的地址, 并在对象中存储一个vptr,指向vtable.我们可以用指针来获取vtable，并且调用vtable中的成员函数。 vtable#include &lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;class Base&#123;public: Base()&#123;;&#125; virtual void f() &#123; cout &lt;&lt;\"Base:hello world\" &lt;&lt;endl; &#125; virtual void g() &#123; cout &lt;&lt;\"Base:g\" &lt;&lt;endl; &#125; virtual void h() &#123; cout &lt;&lt;\"Base:h\" &lt;&lt;endl; &#125;&#125;;class Base_2&#123;public:Base_2()&#123;&#125;virtual void y()&#123;cout&lt;&lt; \"Base_2:y()\" &lt;&lt;endl;&#125;&#125;;class Derive: public Base, public Base_2&#123;public: Derive()&#123; a = 6;&#125; void f() &#123; cout &lt;&lt;\"hello world\" &lt;&lt;endl; cout &lt;&lt;a&lt;&lt;endl; &#125; void g() &#123; cout&lt;&lt;\"Derive:g\"&lt;&lt;endl; &#125; virtual void t()&#123; cout&lt;&lt;\"zmx\"&lt;&lt;endl; &#125; int a;&#125;;typedef void(*Fun)(Derive* ptr);int main() &#123; Derive *q = new Derive(); Derive *p = new Derive(); // Derive *q = dynamic_cast&lt;Derive*&gt;( p); long address = *(long*)q; long address2 = *(long*)p; cout&lt;&lt; address&lt;&lt; endl; cout&lt;&lt; address2&lt;&lt; endl; Fun fun= (Fun)(*(long*)address); fun(q); fun = (Fun)(*(((long*)address)+1)); fun(q); fun = (Fun)(*(((long*)address)+2)); fun(q); fun = (Fun)(*(((long*)address)+3)); fun(q); address = *((long*)q+1); cout&lt;&lt;address&lt;&lt;endl; fun= (Fun)(*(long*)address); fun(q); // fun = (Fun)(*(((long*)address)+1)); // fun(q); // fun = (Fun)(*(((long*)address)+3)); // fun();/* printf(\"sizeof(int)) :%d\\n\",sizeof(int)); printf(\"sizeof(long) :%d\\n\",sizeof(long)); printf(\"sizeof(short) :%d\\n\",sizeof(short)); printf(\"sizeof(char) :%d\\n\",sizeof(char)); printf(\"sizeof(float) :%d\\n\",sizeof(float)); printf(\"sizeof(double):%d\\n\",sizeof(double)); printf(\"sizeof(void*):%d\\n\",sizeof(void*)); printf(\"sizeof(long long):%d\\n\",sizeof(long long));*/ return 0;&#125; 程序的运行结果如下： 在Linux64机器下指针的大小和long的大小一样都是8字节，我们从图中可以看到两个Derive对象中的vptr是一样的，也就是指向同一个vtable,也就是说同类对象的vtable是同一个。而且我们可以看到如果一个派生类有两个基类，两个基类都有virtual function，那么对应于每一个基类都会有各自的虚函数表(vtable),而且如果派生类中还有新的virtual function,会放在第一个基类的vtable中(按照基类的声明顺序),当然如果派生类有重写基类的虚方法，那么vtable中对应的函数会被替换成派生类中的。因为我们的两个基类都没有数据成员，所以派生类对象中的基类部分只有vptr,所以我在获取第二个基类的vptr的时候，直接在第一个基类的地址上移动了一个位置。如果Base类中有一个long类型的成员数据，那么我就得移动两个位置，那才是Base_2类的vptr。可以直接在上面的程序上修改并且运行看看结果。 总结对c++对象模型有了实际的体验，有了进一步的理解. 参考vtablevtablevtable","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"mmap","slug":"mmap","date":"2019-12-03T04:15:38.000Z","updated":"2019-12-03T04:15:38.781Z","comments":true,"path":"2019/12/03/mmap/","link":"","permalink":"http://yoursite.com/2019/12/03/mmap/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Raft","slug":"Raft","date":"2019-11-30T03:34:10.000Z","updated":"2019-11-30T03:34:10.876Z","comments":true,"path":"2019/11/30/Raft/","link":"","permalink":"http://yoursite.com/2019/11/30/Raft/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"实现一个协程dreamcoroutine","slug":"实现一个协程dreamcoroutine","date":"2019-11-30T02:43:27.000Z","updated":"2019-11-30T02:43:27.200Z","comments":true,"path":"2019/11/30/实现一个协程dreamcoroutine/","link":"","permalink":"http://yoursite.com/2019/11/30/实现一个协程dreamcoroutine/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"强化学习调优","slug":"强化学习调优","date":"2019-11-29T13:38:39.000Z","updated":"2019-11-29T13:38:39.820Z","comments":true,"path":"2019/11/29/强化学习调优/","link":"","permalink":"http://yoursite.com/2019/11/29/强化学习调优/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"bayesian optimization","slug":"bayesian-optimization","date":"2019-11-29T13:38:15.000Z","updated":"2019-11-29T13:38:15.806Z","comments":true,"path":"2019/11/29/bayesian-optimization/","link":"","permalink":"http://yoursite.com/2019/11/29/bayesian-optimization/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"深度学习框架的Layer和Net抽象:装饰器模式","slug":"深度学习框架的Layer和Net抽象-装饰器模式","date":"2019-11-28T06:33:12.000Z","updated":"2019-11-28T06:51:43.464Z","comments":true,"path":"2019/11/28/深度学习框架的Layer和Net抽象-装饰器模式/","link":"","permalink":"http://yoursite.com/2019/11/28/深度学习框架的Layer和Net抽象-装饰器模式/","excerpt":"","text":"前言现在完成了GraphExecutor,测试了最简单的一个例子，另外op的正确性先不测试，我打算先把Layer,Net和Solver的整体结构搭建出来。打算参考Caffe，但是肯定要简化好多好多。 LayerNet参考","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"c++可调用对象:仿函数，lambda表达式","slug":"c-可调用对象-仿函数，lambda表达式","date":"2019-11-27T13:36:31.000Z","updated":"2019-11-27T13:36:31.875Z","comments":true,"path":"2019/11/27/c-可调用对象-仿函数，lambda表达式/","link":"","permalink":"http://yoursite.com/2019/11/27/c-可调用对象-仿函数，lambda表达式/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"/dev/urandom","slug":"dev-urandom","date":"2019-11-27T05:43:48.000Z","updated":"2019-11-27T05:43:48.297Z","comments":true,"path":"2019/11/27/dev-urandom/","link":"","permalink":"http://yoursite.com/2019/11/27/dev-urandom/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"caffe的随机数产生方式","slug":"caffe的随机数产生方式","date":"2019-11-27T05:35:59.000Z","updated":"2019-11-27T06:59:27.730Z","comments":true,"path":"2019/11/27/caffe的随机数产生方式/","link":"","permalink":"http://yoursite.com/2019/11/27/caffe的随机数产生方式/","excerpt":"","text":"前言完成了DL框架的执行器，现在需要测试一下，需要为参数给定随机初始值，这里参考caffe的初始值生成方式,从源码来看使用的是boost库，caffe库的代码很不错，后续还要看考它的layer, net的设计。 boost::mt19937参考boost::mt19937","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"虚函数表","slug":"虚函数表","date":"2019-11-26T13:41:10.000Z","updated":"2019-11-26T13:41:10.106Z","comments":true,"path":"2019/11/26/虚函数表/","link":"","permalink":"http://yoursite.com/2019/11/26/虚函数表/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"noexcept","slug":"noexcept","date":"2019-11-26T13:01:26.000Z","updated":"2019-11-26T13:01:26.415Z","comments":true,"path":"2019/11/26/noexcept/","link":"","permalink":"http://yoursite.com/2019/11/26/noexcept/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"std::function","slug":"std-function","date":"2019-11-26T13:01:11.000Z","updated":"2019-11-26T13:01:11.315Z","comments":true,"path":"2019/11/26/std-function/","link":"","permalink":"http://yoursite.com/2019/11/26/std-function/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"memory pool","slug":"memory-pool","date":"2019-11-26T08:56:03.000Z","updated":"2019-11-26T09:07:12.163Z","comments":true,"path":"2019/11/26/memory-pool/","link":"","permalink":"http://yoursite.com/2019/11/26/memory-pool/","excerpt":"","text":"前言最近继续写DL框架，因为涉及到频繁的new内存，开销很大会拖慢速度，所以准备用memory pool, 先开一个比较大的空间，这样的程序性能应该能提高。 理论首先我们来学习一下内存池的理论，从字面意思上来看，内存池里应该有很多的内存，当我们需要一块内存的时候我们不用new或者malloc,而是从内存池里去拿就行，这样就减少了分配内存的开销，从而提升性能，不知道一次new操作会带来多大的开销呢? 参考","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"tensorflow Distribution Strategy API","slug":"tensorflow-Distribution-Strategy-API","date":"2019-11-25T06:35:43.000Z","updated":"2019-11-25T06:37:42.161Z","comments":true,"path":"2019/11/25/tensorflow-Distribution-Strategy-API/","link":"","permalink":"http://yoursite.com/2019/11/25/tensorflow-Distribution-Strategy-API/","excerpt":"","text":"前言参考Distribution Strategy API","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"SparseTensor","slug":"SparseTensor","date":"2019-11-24T11:26:20.000Z","updated":"2019-11-24T12:28:47.074Z","comments":true,"path":"2019/11/24/SparseTensor/","link":"","permalink":"http://yoursite.com/2019/11/24/SparseTensor/","excerpt":"","text":"前言最近看论文发现tf的Tensor分为 dense tensor 和 sparse tensor. 而 这篇论文就是对不同类型的tensor使用不同的梯度聚合架构，从而提出了一个混合架构,用于分布式深度学习数据并行训练。 参考Update only part of the word embedding matrix in Tensorflow","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"vector clock","slug":"vector-clock","date":"2019-11-24T07:42:52.000Z","updated":"2019-12-07T11:13:45.151Z","comments":true,"path":"2019/11/24/vector-clock/","link":"","permalink":"http://yoursite.com/2019/11/24/vector-clock/","excerpt":"","text":"前言在分布式系统中，我们想要确定事件的因果关系，也就是事件发生的前后顺序，与此有关的算法有 Lamport clock, vector clock。 Lamport clockvector clock参考Lamport’s Logical Clocks 和 Vector Clock","categories":[],"tags":[{"name":"distributed systems","slug":"distributed-systems","permalink":"http://yoursite.com/tags/distributed-systems/"}]},{"title":"distributed kv store","slug":"distributed-kv-store","date":"2019-11-24T06:32:54.000Z","updated":"2019-11-24T06:32:54.594Z","comments":true,"path":"2019/11/24/distributed-kv-store/","link":"","permalink":"http://yoursite.com/2019/11/24/distributed-kv-store/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"paxos and raft","slug":"paxos-and-raft","date":"2019-11-24T06:24:56.000Z","updated":"2019-11-24T06:25:50.957Z","comments":true,"path":"2019/11/24/paxos-and-raft/","link":"","permalink":"http://yoursite.com/2019/11/24/paxos-and-raft/","excerpt":"","text":"参考github paxos raft","categories":[],"tags":[{"name":"distributed system","slug":"distributed-system","permalink":"http://yoursite.com/tags/distributed-system/"}]},{"title":"in graph and between graph","slug":"in-graph-and-between-graph","date":"2019-11-24T06:11:42.000Z","updated":"2019-11-24T06:11:42.519Z","comments":true,"path":"2019/11/24/in-graph-and-between-graph/","link":"","permalink":"http://yoursite.com/2019/11/24/in-graph-and-between-graph/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"MIT6.824 lab1 mapreduce","slug":"MIT6-824-lab1-mapreduce","date":"2019-11-24T02:38:26.000Z","updated":"2019-11-24T02:38:26.038Z","comments":true,"path":"2019/11/24/MIT6-824-lab1-mapreduce/","link":"","permalink":"http://yoursite.com/2019/11/24/MIT6-824-lab1-mapreduce/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"std::mutex","slug":"std-mutex","date":"2019-11-23T17:11:32.000Z","updated":"2019-11-23T17:13:44.666Z","comments":true,"path":"2019/11/24/std-mutex/","link":"","permalink":"http://yoursite.com/2019/11/24/std-mutex/","excerpt":"","text":"前言最近看ps-lite代码，因为代码很多地方会涉及到多线程，有互斥量，条件变量等等。对c++11的多线程没怎么学过，所以就学习了一下。 std::mutex参考","categories":[],"tags":[{"name":"c++11","slug":"c-11","permalink":"http://yoursite.com/tags/c-11/"}]},{"title":"MPI_Irecv","slug":"MPI-Irecv","date":"2019-11-22T07:55:06.000Z","updated":"2019-11-22T08:38:38.110Z","comments":true,"path":"2019/11/22/MPI-Irecv/","link":"","permalink":"http://yoursite.com/2019/11/22/MPI-Irecv/","excerpt":"","text":"前言看baidu的allreduce实现，第一部分的ring reduce scatter用到了这个函数，所以来学习一下。 参考MPI_Irecv","categories":[],"tags":[{"name":"MPI","slug":"MPI","permalink":"http://yoursite.com/tags/MPI/"}]},{"title":"a hybrid framework providing ps and allreduce architecture for distributed deep learning","slug":"a-hybrid-framework-providing-ps-and-allreduce-architecture-for-distributed-deep-learning","date":"2019-11-22T06:53:13.000Z","updated":"2019-11-22T06:53:13.179Z","comments":true,"path":"2019/11/22/a-hybrid-framework-providing-ps-and-allreduce-architecture-for-distributed-deep-learning/","link":"","permalink":"http://yoursite.com/2019/11/22/a-hybrid-framework-providing-ps-and-allreduce-architecture-for-distributed-deep-learning/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"byteps源码解析(-)","slug":"byteps源码解析","date":"2019-11-21T20:15:47.000Z","updated":"2019-11-21T20:15:47.456Z","comments":true,"path":"2019/11/22/byteps源码解析/","link":"","permalink":"http://yoursite.com/2019/11/22/byteps源码解析/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ps-lite实现异步sgd","slug":"ps-lite实现异步sgd","date":"2019-11-21T20:15:34.000Z","updated":"2019-11-21T20:15:34.650Z","comments":true,"path":"2019/11/22/ps-lite实现异步sgd/","link":"","permalink":"http://yoursite.com/2019/11/22/ps-lite实现异步sgd/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ps-lite的通信初始化","slug":"ps-lite的通信初始化","date":"2019-11-21T20:15:12.000Z","updated":"2019-11-21T20:15:12.120Z","comments":true,"path":"2019/11/22/ps-lite的通信初始化/","link":"","permalink":"http://yoursite.com/2019/11/22/ps-lite的通信初始化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"在ps-lite中添加对变长value的支持","slug":"在ps-lite中添加对变长value的支持","date":"2019-11-21T19:43:03.000Z","updated":"2019-11-21T19:43:03.281Z","comments":true,"path":"2019/11/22/在ps-lite中添加对变长value的支持/","link":"","permalink":"http://yoursite.com/2019/11/22/在ps-lite中添加对变长value的支持/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"MPI SendRecv","slug":"MPI-SendRecv","date":"2019-11-19T15:37:23.000Z","updated":"2019-11-22T09:49:57.830Z","comments":true,"path":"2019/11/19/MPI-SendRecv/","link":"","permalink":"http://yoursite.com/2019/11/19/MPI-SendRecv/","excerpt":"","text":"前言baidu allreduce 代码中用SendRecv实现了ring Allgather, 如果用 Send和Receive来实现的话，因为两个都是阻塞的，所以会死锁，一个解决方法是使用Irecv和Send,另一种方法就是使用SendRecv。 实践该函数的接口如下:int MPI_Sendrecv(const void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status) 每个参数都顾名思义，sendbuf是要发送的数据的地址，sendcount和sendtype是要发送数据的数量和类型，dest是目的进程的rank, sendtag和recvtag对应就好。recvbuf和recvcount是接收数据的缓冲区和接收的数量以及接收的类型,source表示从哪个进程接收,status应该是receive操作的状态。 我们用一个ring的例子来实践一下该函数,代码如下：#include&lt;stdio.h&gt;#include \"mpi.h\"#include &lt;math.h&gt;int main(int argc, char* argv[])&#123; int nProcs, Rank, i; double A0,A1; MPI_Status status; MPI_Init(&amp;argc, &amp;argv); MPI_Comm_size(MPI_COMM_WORLD, &amp;nProcs); MPI_Comm_rank(MPI_COMM_WORLD, &amp;Rank); // for(int i=0; i&lt;n; i++)&#123; // A0[i] = Rank; // A1[i] = Rank; // &#125; printf(\"\\nBefore exchange A0 A1:\\n\"); //for(i=0;i&lt;n;i++)&#123; printf(\"rank:%d\\t%f\\t%f\\n\",Rank, A0, A1); //&#125; int rightrank = (Rank + 1) % nProcs; int leftrank = (Rank + nProcs-1)%nProcs; MPI_Barrier(MPI_COMM_WORLD); MPI_Sendrecv(&amp;A0, 1, MPI_DOUBLE, rightrank,990, &amp;A1, 1, MPI_DOUBLE, leftrank,990, MPI_COMM_WORLD,&amp;status); MPI_Finalize(); printf(\"After exchange A0 A1\\n\"); // for(i=0;i&lt;n;i++)&#123; printf(\"rank:%d %f\\t%f\\n\",Rank, A0, A1); // &#125;&#125; 该代码的运行结果如下，可以看到每个进程都从它左边的进程接收了A1,因为每个进程都发送A0,所以A0是不变的 参考MPI_SendRecvMPI_SendRecv","categories":[],"tags":[{"name":"MPI","slug":"MPI","permalink":"http://yoursite.com/tags/MPI/"}]},{"title":"MPI Bcast,Gather,AllGather","slug":"MPI-Bcast-Gather-AllGather","date":"2019-11-19T02:51:32.000Z","updated":"2019-11-19T15:36:02.769Z","comments":true,"path":"2019/11/19/MPI-Bcast-Gather-AllGather/","link":"","permalink":"http://yoursite.com/2019/11/19/MPI-Bcast-Gather-AllGather/","excerpt":"","text":"前言这几天看allreduce算法，发现基本的概念还是MPI那一套，而NCCL,baidu-allreduce都是集合通信的具体实现。所以回顾一下各个函数的意义。 MPI_ReduceMPI_Scatterscatter是把root进程拥有的一个数组分块，块数等于进程数，并根据进程的秩来发送对应块，第一块发送给进程0，以此类推。函数接口如下：MPI_Scatter( void* send_data, int send_count, MPI_Datatype send_datatype, void* recv_data, int recv_count, MPI_Datatype recv_datatype, int root, MPI_Comm communicator) 测试代码如下： 但是存在一个问题，如果数组的长度不能被进程数整除怎么办。 MPI_Bcastbroadcast就是把root进程的数据发送到其他的所有进程。示意图如下:函数接口如下： MPI_GatherMPI_Gather的作用就是把其他所有进程的数据收集到root进程来，和reduce不同的是没有reduce操作,只是单纯的收集。示意图如下： 接口如下:MPI_Gather( void* send_data, int send_count, MPI_Datatype send_datatype, void* recv_data, int recv_count, MPI_Datatype recv_datatype, int root, MPI_Comm communicator) send_data, send_count以及send_datatype都是发送数据的参数，意思也是很明显的。receive同理，这里有一个root参数用来指定root进程。对于root进程需要秩指定recv_data,其他进程可以传递NULL给recv_data,实践发现对于其他进程recv_count和recv_datatype也是可以胡乱指定的。程序如下： #include&lt;mpi.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdexcept&gt;#include&lt;cstring&gt;int main(int argc,char* argv[])&#123;int mpi_error ;mpi_error = MPI_Init(NULL,NULL);if(mpi_error!=MPI_SUCCESS)&#123; throw std::runtime_error(\"MPI_Init failed with an error\");&#125;int rank,size;mpi_error = MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);if(mpi_error!=MPI_SUCCESS)&#123;throw std::runtime_error(\"MPI_Comm_rank failed with an error\");&#125;mpi_error = MPI_Comm_size(MPI_COMM_WORLD,&amp;size);if(mpi_error!=MPI_SUCCESS)&#123;throw std::runtime_error(\"MPI_Comm_size failed with an error\");&#125;size_t length = rank;std::vector&lt;size_t&gt; lengths(size);//MPI_Allgather(&amp;length,1,MPI_UNSIGNED_LONG,&amp;lengths[0],1,MPI_UNSIGNED_LONG,MPI_COMM_WORLD);if(rank==0)&#123;MPI_Allgather(&amp;length,1,MPI_UNSIGNED_LONG,&amp;lengths[0],1,MPI_UNSIGNED_LONG,MPI_COMM_WORLD);for(auto t:lengths)&#123; std::cout&lt;&lt; t &lt;&lt; std::endl;&#125;&#125;else&#123;MPI_Allgather(&amp;length,1,MPI_UNSIGNED_LONG,NULL,1,MPI_UNSIGNED_LONG,MPI_COMM_WORLD);&#125;MPI_Finalize();return 0;&#125; MPI_AllgatherMPI_Gather将其他所有进程的数据收集到root进程上,与MPI_Scatter相反。而MPI_Allgather也是收集所有进程上的数据，但是它不仅仅将数据收集到root进程，而是收集到所有的进程，图示如下：在每个进程上，收到的数据都会按照发送该数据的进程的秩来排序。Allgather的接口如下:MPI_Allgather( void* send_data, int send_count, MPI_Datatype send_datatype, void* recv_data, int recv_count, MPI_Datatype recv_datatype, MPI_Comm communicator) send_data,send_count,send_datatype分别是每个进程要发送的数据地址，发送的数据量以及数据的类型，需要注意的是接收部分的参数，recv_data是接收数据缓冲区，recv_count表示的是从每个进程接收多少数据而不是从其他进程接收的总的数据，这个要注意。其他的都很清楚。我们用一个简单的程序来实践一下，我们用MPI process的秩来初始化该进程的length变量,然后将length发送出去，当Allgather过程结束后，每个进程应该会有一个 数组，长度为总的进程数，然后里面的值为每个进程的length变量值，按照进程的秩排好序的。程序如下：#include&lt;mpi.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdexcept&gt;#include&lt;cstring&gt;int main(int argc,char* argv[])&#123;int mpi_error ;mpi_error = MPI_Init(NULL,NULL);if(mpi_error!=MPI_SUCCESS)&#123; throw std::runtime_error(\"MPI_Init failed with an error\");&#125;int rank,size;mpi_error = MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);if(mpi_error!=MPI_SUCCESS)&#123;throw std::runtime_error(\"MPI_Comm_rank failed with an error\");&#125;mpi_error = MPI_Comm_size(MPI_COMM_WORLD,&amp;size);if(mpi_error!=MPI_SUCCESS)&#123;throw std::runtime_error(\"MPI_Comm_size failed with an error\");&#125;size_t length = rank;std::vector&lt;size_t&gt; lengths(size);MPI_Allgather(&amp;length,1,MPI_UNSIGNED_LONG,&amp;lengths[0],1,MPI_UNSIGNED_LONG,MPI_COMM_WORLD);if(rank==0)&#123;for(auto t:lengths)&#123; std::cout&lt;&lt; t &lt;&lt; std::endl;&#125;&#125;MPI_Finalize();return 0;&#125; 开了10个进程，运行结果如下： 参考MPI AllgatherMPI scatter gather allgather","categories":[],"tags":[{"name":"MPI","slug":"MPI","permalink":"http://yoursite.com/tags/MPI/"}]},{"title":"horovod","slug":"horovod","date":"2019-11-17T03:29:59.000Z","updated":"2019-11-24T06:11:19.313Z","comments":true,"path":"2019/11/17/horovod/","link":"","permalink":"http://yoursite.com/2019/11/17/horovod/","excerpt":"","text":"参考horovod 知乎","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"给ps-lite添加Angel中的psFunc","slug":"给ps-lite添加Angel中的psFunc","date":"2019-11-16T12:29:50.000Z","updated":"2019-11-22T12:48:39.846Z","comments":true,"path":"2019/11/16/给ps-lite添加Angel中的psFunc/","link":"","permalink":"http://yoursite.com/2019/11/16/给ps-lite添加Angel中的psFunc/","excerpt":"","text":"前言实验室项目想把ps设计的更好，要求借鉴Angel提供psFunc,以便后续能提供对一些传统ML算法的支持，包括GBDT,LDA等。一开始并不是很懂这个psFunc有什么用，看了一下Angel的文档，当然这个Angel也是实验室和腾讯合作搞出来的。 psFuncpsFunc是在sever端的一些自定义函数，最简单的ps只提供模型的存储功能，但是针对一些特定的算法我们需要一些优化，如果我们要对模型参数进行一些操作得到某个结果，如果ps只提供了最简单的pull功能，那我们就要把模型参数从ps上全部拉过来，然后在worker上计算得到结果。这样的做法网络通信开销很大，如果server端能够提供这样的功能，那worker发一个请求，server端执行计算返回一个结果数值就好了，这样网络通信开销会大幅度降低，毕竟server也是有计算能力的，浪费掉很可惜啊。这样的想法很直观。感觉优化提升应该也不错。如下是Angel的文档: 设计参考Angel 2.0 用户手册","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"ReduceScatter+Allgather","slug":"ReduceScatter-Allgather","date":"2019-11-16T08:16:24.000Z","updated":"2019-11-22T10:09:00.645Z","comments":true,"path":"2019/11/16/ReduceScatter-Allgather/","link":"","permalink":"http://yoursite.com/2019/11/16/ReduceScatter-Allgather/","excerpt":"","text":"前言Ring Allreduce架构也是一种常用的梯度同步架构，它的通信成本与gpu的数量无关。它是Allreduce算法的一种高效实现。目前常用的分布式深度学习的框架基本就是ps架构和Ring Allreduce架构。在这篇博客中，我会首先来回顾一下最简单的Allreduce算法的实现，然后是Ring Allreduce算法的实现，并给出baidu all-reduce的源码分析。 理论Allreduce 是一种集合通信原语，它的规范的定义如下： AllReduce is an operation that reduces the target arrays in all processes to a single array and returns the resultant array to all processes. 简单来说就是有很多个进程，每个进程都有一个目标数组，Allreduce要做的就是将所有进程中的数组收集起来做一个reduce操作成单个的数组，然后将这单个的数组重新发送给所有的进程。就是一个reduce+broadcast的操作。很容易理解，要实现Allreduce一个最简单的算法就是用一个process当master，其他的进程把自己的数组发送给master, master收集完后做一个reduce操作，然后再将结果数组发送给其余的所有进程，和ps架构一样。图示如下： 我们计算一下这种实现的通信量,假设数组的长度是N,总共有P个进程,那么第一步有P-1个进程将数组发送到master进程,然后master进程将reduce后的数组发送给P-1个进程，所以master总共的通信量是2(P-1)*N. 可以看到master的通信量和gpu的数量是线性关系的。而且master的带宽限制使得master成了一个瓶颈。 而Ring Allreduce作为Allreduce算法的一个高效实现，它消除了master的瓶颈，使得系统的通信成本和gpu的数量无关，是一个恒定值。在该算法中，所有的gpu排列成一个环，我们给gpu标号，从0~N-1.按照顺时针的方向，每个gpu会有一个左边的邻居和右边的邻居，每个迭代中，当前gpu从左邻居中接受数据，发送数据给右边的邻居.图示如下： 我们来具体介绍算法流程: 首先，在每个gpu上，把长度为N的数组切分成P个chunks,P是进程的数量。接下来进行P-1次Scatter-Reduce迭代，第一次迭代，编号为n的gpu,将第n块发送给它的右邻居，从它的左邻居接收第n-1块。后面的每次迭代，每块gpu都将上一轮迭代接收到的块进行reduce操作后发送给它的右邻居。以下是第一次迭代，第二次迭代和最后一次迭代的图示： 可以看到P-1次Reduce-Scatter迭代完成后，每个gpu都拥有最终结果的其中一块。我们需要把每个gpu中的这个块发送到其他gpu，这次每个gpu接收到块以后不是reduce操作，是直接覆盖对应块的内容即可。方法是通过P-1次Allgather迭代，第一次迭代，第n个gpu发送第n+1个块接收第n个块.后续的迭代和Reduce-Scatter一样，也是发送上一轮迭代接收的到的块.下面是第一轮，第二轮以及最后的图示： 我们分析这个ring算法的总的通信量, 总共是2(p-1)次迭代，每个迭代每块gpu都发送 N/P 的数据，所以每个gpu发送的数据量和接收的数据量都是 2(P-1)N/P, 最后的结果与P无关。通过对比可以看到，ring allreduce算法的通信量更少而且与gpu数量无关，扩展性更好。 其实allreduce算法有很多种，还有 tree-allreduce等，像Rabit库中实现的应该是tree-allreduce, 后续可以补充。ring allreduce在通信上应该是最优的. 本篇博客中的所有图都截取自参考资料[5]. 实践我们通过对baidu all-reduce源码的解读和应用来实践ring all-reduce算法.baidu allreduce源码的层次结构如下：可以看到源码的量很少，其中最关键的就是collectives.cu文件，实现了 Ring Allreduce和 Ring Allgather两个函数。下面我们来看一些help function,理解了这些help function,再看最重要的部分就都能理解了。 Reference[1]Ring Allreduce[2]All Reduce[3]Rabit[4]baidu all-reduce[5]Bringing HPC Techniques to Deep Learning","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"bytescheduler在byteps中的实现","slug":"bytescheduler在byteps中的实现","date":"2019-11-16T08:15:54.000Z","updated":"2019-11-16T08:15:54.128Z","comments":true,"path":"2019/11/16/bytescheduler在byteps中的实现/","link":"","permalink":"http://yoursite.com/2019/11/16/bytescheduler在byteps中的实现/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"cuda Stream","slug":"cuda-Stream","date":"2019-11-14T02:43:20.000Z","updated":"2019-11-14T02:43:20.370Z","comments":true,"path":"2019/11/14/cuda-Stream/","link":"","permalink":"http://yoursite.com/2019/11/14/cuda-Stream/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"python的with语句以及__enter__和__exit__","slug":"python的with语句以及-enter-和-exit","date":"2019-11-10T08:27:21.000Z","updated":"2019-11-12T06:41:36.435Z","comments":true,"path":"2019/11/10/python的with语句以及-enter-和-exit/","link":"","permalink":"http://yoursite.com/2019/11/10/python的with语句以及-enter-和-exit/","excerpt":"","text":"前言想写一个DL的框架，前端想模仿tensorflow来写，看到 with tf.Graph().as_default, 就想看看Graph类如何定义，看到一个simpleflow的github项目，里面Graph的定义里有 enter和exit方法，不明白是什么意思就随手一查，反而让我知道了with语法的内部机制,算是一个比较大的收获。 参考python enter 与 exit的作用，以及与 with 语句的关系","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"阅读论文《A Generic Communication Scheduler for Distributed DNN Training Acceleration》","slug":"阅读论文《A-Generic-Communication-Scheduler-for-Distributed-DNN-Training-Acceleration》","date":"2019-10-28T03:17:05.000Z","updated":"2019-10-29T03:12:38.827Z","comments":true,"path":"2019/10/28/阅读论文《A-Generic-Communication-Scheduler-for-Distributed-DNN-Training-Acceleration》/","link":"","permalink":"http://yoursite.com/2019/10/28/阅读论文《A-Generic-Communication-Scheduler-for-Distributed-DNN-Training-Acceleration》/","excerpt":"","text":"AbstractIntroduction","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"c++ typename的用法","slug":"c-typename的用法","date":"2019-09-23T16:09:35.000Z","updated":"2019-09-23T16:09:35.792Z","comments":true,"path":"2019/09/24/c-typename的用法/","link":"","permalink":"http://yoursite.com/2019/09/24/c-typename的用法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"生产者消费者模型","slug":"生产者消费者模型","date":"2019-09-19T15:54:40.000Z","updated":"2019-12-23T19:41:38.889Z","comments":true,"path":"2019/09/19/生产者消费者模型/","link":"","permalink":"http://yoursite.com/2019/09/19/生产者消费者模型/","excerpt":"","text":"前言生产者消费者模型是著名的线程同步模型，在实际的工业产品中都体现着这种模型。 问题有一个大小为N的buffer,有多个线程对其进行操作，这些线程分为两类，分别是生产者和消费者，其中生产者生产数据并放到buffer里，消费者从buffer里取数据消费。如果buffer满了，那么生产者不能继续生产数据，如果buffer为空，那么消费者不能消费数据.以及同一时刻只能有一个线程来访问buffer. 实现使用一个mutex和两个semaphores(信号量)来实现 full = semaphore(0)empty = semaphore(N)mutex = 1 生产者: p(empty)p(mutex) // 多个线程之间的互斥，同一时刻只能有一个线程来访问buffer.produce()放入bufferv(mutex)v(full) 消费者: p(full)p(mutex)从buffer取出,consume()v(mutex)v(empty) 总结可以看到在一个进程中p都在v之前.在一个进程执行对一个信号量的p，在另一个进程执行对该信号量的v. 参考生产者消费者模型","categories":[],"tags":[{"name":"operating system","slug":"operating-system","permalink":"http://yoursite.com/tags/operating-system/"}]},{"title":"c++11 std::thread","slug":"c-11-std-thread","date":"2019-09-18T07:48:21.000Z","updated":"2019-09-18T07:48:21.117Z","comments":true,"path":"2019/09/18/c-11-std-thread/","link":"","permalink":"http://yoursite.com/2019/09/18/c-11-std-thread/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"同步sgd/异步sgd","slug":"同步sgd-异步sgd","date":"2019-09-10T06:28:03.000Z","updated":"2019-09-10T06:28:03.061Z","comments":true,"path":"2019/09/10/同步sgd-异步sgd/","link":"","permalink":"http://yoursite.com/2019/09/10/同步sgd-异步sgd/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"论文阅读: Parameter Server for Distributed Machine Learning","slug":"论文阅读-Parameter-Server-for-Distributed-Machine-Learning","date":"2019-08-30T07:25:21.000Z","updated":"2019-08-30T07:25:21.122Z","comments":true,"path":"2019/08/30/论文阅读-Parameter-Server-for-Distributed-Machine-Learning/","link":"","permalink":"http://yoursite.com/2019/08/30/论文阅读-Parameter-Server-for-Distributed-Machine-Learning/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"参数同步架构和算法","slug":"参数同步架构和算法","date":"2019-08-30T05:28:38.000Z","updated":"2019-08-30T05:28:38.656Z","comments":true,"path":"2019/08/30/参数同步架构和算法/","link":"","permalink":"http://yoursite.com/2019/08/30/参数同步架构和算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ring AllReduce","slug":"ring-AllReduce","date":"2019-08-27T04:46:33.000Z","updated":"2019-08-27T04:46:33.224Z","comments":true,"path":"2019/08/27/ring-AllReduce/","link":"","permalink":"http://yoursite.com/2019/08/27/ring-AllReduce/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"FM/DeepFM/NFM","slug":"FM-DeepFM-NFM","date":"2019-08-22T00:17:38.000Z","updated":"2019-08-22T00:17:38.721Z","comments":true,"path":"2019/08/22/FM-DeepFM-NFM/","link":"","permalink":"http://yoursite.com/2019/08/22/FM-DeepFM-NFM/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"分布式爬虫+推荐","slug":"分布式爬虫-推荐","date":"2019-08-16T01:32:41.000Z","updated":"2019-08-16T01:32:41.462Z","comments":true,"path":"2019/08/16/分布式爬虫-推荐/","link":"","permalink":"http://yoursite.com/2019/08/16/分布式爬虫-推荐/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"分布式文件系统","slug":"分布式文件系统","date":"2019-08-16T01:31:03.000Z","updated":"2019-08-16T01:31:03.261Z","comments":true,"path":"2019/08/16/分布式文件系统/","link":"","permalink":"http://yoursite.com/2019/08/16/分布式文件系统/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"GBDT","slug":"GBDT","date":"2019-08-07T12:23:34.000Z","updated":"2019-08-07T12:23:34.339Z","comments":true,"path":"2019/08/07/GBDT/","link":"","permalink":"http://yoursite.com/2019/08/07/GBDT/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"meta learning","slug":"meta-learning","date":"2019-08-05T13:38:24.000Z","updated":"2019-08-05T13:38:24.643Z","comments":true,"path":"2019/08/05/meta-learning/","link":"","permalink":"http://yoursite.com/2019/08/05/meta-learning/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"自动微分","slug":"自动微分","date":"2019-08-05T12:52:52.000Z","updated":"2019-08-06T13:55:55.989Z","comments":true,"path":"2019/08/05/自动微分/","link":"","permalink":"http://yoursite.com/2019/08/05/自动微分/","excerpt":"","text":"符号微分数值微分前向自动微分反向自动微分参考一天实现自己的自动微分自动微分简介tensorflow 自动微分c++ 实现自动微分wikpedia automatic differentiation自动微分法是如何用c++实现的","categories":[],"tags":[{"name":"deep learning system","slug":"deep-learning-system","permalink":"http://yoursite.com/tags/deep-learning-system/"}]},{"title":"beam search","slug":"beam-search","date":"2019-08-05T04:41:08.000Z","updated":"2019-08-05T04:41:08.863Z","comments":true,"path":"2019/08/05/beam-search/","link":"","permalink":"http://yoursite.com/2019/08/05/beam-search/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"隐马尔可夫模型","slug":"隐马尔可夫模型","date":"2019-08-05T04:40:50.000Z","updated":"2019-08-05T04:40:50.934Z","comments":true,"path":"2019/08/05/隐马尔可夫模型/","link":"","permalink":"http://yoursite.com/2019/08/05/隐马尔可夫模型/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RNN梯度消失和爆炸","slug":"RNN梯度消失和爆炸","date":"2019-08-04T15:48:57.000Z","updated":"2019-08-05T03:27:12.317Z","comments":true,"path":"2019/08/04/RNN梯度消失和爆炸/","link":"","permalink":"http://yoursite.com/2019/08/04/RNN梯度消失和爆炸/","excerpt":"","text":"","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://yoursite.com/tags/deep-learning/"}]},{"title":"BPTT","slug":"BP反向传播-BPTT","date":"2019-08-04T15:05:30.000Z","updated":"2019-08-08T14:15:38.122Z","comments":true,"path":"2019/08/04/BP反向传播-BPTT/","link":"","permalink":"http://yoursite.com/2019/08/04/BP反向传播-BPTT/","excerpt":"","text":"BPTT (BackPropagation Through Time)用于循环神经网络的BP算法.首先我们回顾一下RNN,RNN的网络结构图如下： 标准RNN的数学表达式如下: s(t) = Ux(t)+Wh(t-1)+bh(t) = tanh(s(t))z(t) = Vh(t)+c\\hat{y(t)} = softmax(z(t))$ U $ , $ W $ , $ V $ 是待优化的参数. 上面的表达式可以和图对应,RNN网络的参数在所有时间步都是共享的.我们参考材料[2]的记法，将公式细化如下:首先我们计算s(t)的第j个元素,我们假设输入 $ x(t) $的维度是 $ l $ , 隐藏层的状态 $ h(t) $ 的维度是 $ m $ : s_j(t) = \\sum_{i=1}^{l} {x_i(t)u_{ji} + \\sum_{k=1}^{m} { h_k(t-1)wjk }}+b_j下面我们计算 $ z(t) $ 的第j个元素: z_j(t) = \\sum_{q=1}^{m} {h_q(t)v_{jq}}+c_j因为每个时间步的输出都是一个概率向量，表示该时间步的词所属于各标签的概率分布，如果用one-hot向量表示真实标签$ y_t $，那么输出$ \\hat{y_t} $和$ y_t $可以计算交叉熵损失$ E_t $, 公式如下： E_t = -{y_t}^T \\ln( \\hat{y_t})E = \\sum_{t=1}^{T} {E_t}我们要用损失函数 $ E $ 对 $ U $ , $ W $ , $ V $ 求偏导数，然后更新参数,我么使用sgd 算法所以每次更新使用一个样本. 我们拿出一个时间步的损失，并就该损失求$ U $ , $ W $ , $ V $ 的更新，结构图如下：我们假设输出的概率分布的维度是 $ o $ , 并把时间维度 $ t $ 舍去, 那么: E_t = -{y_t}^T \\ln( \\hat{y_t}) = \\sum_{k=1}^{o} { -y_k \\ln \\hat{y_k} }\\frac{ \\partial E_t }{ \\partial \\hat{y_k} } = - \\frac{y_k}{ \\hat{y_k} }\\frac{ \\partial \\hat{y_k} }{ \\partial z_j } = \\begin{cases} \\hat{y_j}(1- \\hat{y_j} ) & \\text{ k = j }\\\\ - \\hat{y_k} { \\hat{y_j }}& \\text{ j != k } \\end{cases}综上： \\frac{ \\partial E_t }{ \\partial z_j } = \\sum_{k=1}^{o} { \\frac{ \\partial E_t}{ \\partial \\hat{y_k} } \\frac{ \\partial \\hat{y_k} }{ \\partial z_j } } = y_j - \\hat{y_j}\\frac{ \\partial z_j }{ \\partial v_{jq}} = h_q\\frac{ \\partial E_t }{ \\partial v_{jq}} = \\frac{ \\partial E_t }{ \\partial z_j } \\frac{ \\partial z_j }{ \\partial v_{jq}} =( y_j - \\hat{y_j} )h_q根据上面的式子，我们能对矩阵v的所有元素进行更新.下面我们计算 $ U $ 和 $ W $ 的更新式子: \\frac{ \\partial E_t }{ \\partial h_q } = \\sum_{j=1}^{o} {\\frac{ \\partial E_t}{ \\partial z_j} \\frac{ \\partial z_j}{ \\partial h_q} } = \\sum_{j=1}^{o} {(y_j - \\hat{y_j} )v_{jq}}\\frac{ \\partial E_t }{ \\partial s_q } = \\frac{ \\partial E_t }{ \\partial h_q } \\frac{ \\partial h_q }{ \\partial s_q } = [ \\sum_{j=1}^{o} {(y_j - \\hat{y_j} )v_{jq}} ](1- {tanh(s_q)}^2)\\frac{ \\partial E_t }{ \\partial u_{qi} } = \\frac{ \\partial E_t }{ \\partial s_q } \\frac{ \\partial s_q }{ \\partial u_{qi} } = [ \\sum_{j=1}^{o} {(y_j - \\hat{y_j} )v_{jq}} ](1- {tanh(s_q)}^2) x_i\\frac{ \\partial E_t }{ \\partial w_{qk} } = \\frac{ \\partial E_t }{ \\partial s_q } \\frac{ \\partial s_q }{ \\partial w_{qk} } = [ \\sum_{j=1}^{o} {(y_j - \\hat{y_j} )v_{jq}} ](1- {tanh(s_q)}^2) h_k(t-1)W更新\\frac{ \\partial E}{ \\partial W} = \\sum_{t=1}^{T} { \\frac{ \\partial E_t }{ \\partial W }}\\frac{ \\partial E_t }{ \\partial W } = \\frac{ \\partial E_t }{ \\partial \\hat{y_t} } \\frac{ \\partial \\hat{y_t} }{ \\partial W }\\frac{ \\partial E_t }{ \\partial \\hat{y_t} } = - \\frac{y_t}{ \\hat{y_t}}这里的除法是element-wise的.然后是$ \\frac{ \\partial \\hat{y_t} }{ \\partial W } $ ，这是一个向量对一个矩阵求偏导 参考BPTT blogbptt","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://yoursite.com/tags/deep-learning/"}]},{"title":"simpledb(1)","slug":"simpledb-1","date":"2019-08-04T15:05:00.000Z","updated":"2019-08-04T15:05:00.025Z","comments":true,"path":"2019/08/04/simpledb-1/","link":"","permalink":"http://yoursite.com/2019/08/04/simpledb-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"c++11之std::move","slug":"c-11之std-move","date":"2019-07-29T13:47:36.000Z","updated":"2019-07-29T13:47:36.045Z","comments":true,"path":"2019/07/29/c-11之std-move/","link":"","permalink":"http://yoursite.com/2019/07/29/c-11之std-move/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"c++11之多线程std::thread","slug":"c-11之多线程std-thread","date":"2019-07-29T13:37:11.000Z","updated":"2019-07-29T13:38:22.099Z","comments":true,"path":"2019/07/29/c-11之多线程std-thread/","link":"","permalink":"http://yoursite.com/2019/07/29/c-11之多线程std-thread/","excerpt":"","text":"","categories":[],"tags":[{"name":"c++11","slug":"c-11","permalink":"http://yoursite.com/tags/c-11/"}]},{"title":"sqlite architecture","slug":"sqlite-architecture","date":"2019-07-29T13:04:39.000Z","updated":"2019-07-29T13:06:52.185Z","comments":true,"path":"2019/07/29/sqlite-architecture/","link":"","permalink":"http://yoursite.com/2019/07/29/sqlite-architecture/","excerpt":"","text":"","categories":[],"tags":[{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"}]},{"title":"database index","slug":"database-index","date":"2019-07-29T13:04:04.000Z","updated":"2019-07-29T13:08:01.007Z","comments":true,"path":"2019/07/29/database-index/","link":"","permalink":"http://yoursite.com/2019/07/29/database-index/","excerpt":"","text":"","categories":[],"tags":[{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"}]},{"title":"B/B+ Tree","slug":"B-B-Tree","date":"2019-07-27T15:18:02.000Z","updated":"2019-07-29T13:07:30.190Z","comments":true,"path":"2019/07/27/B-B-Tree/","link":"","permalink":"http://yoursite.com/2019/07/27/B-B-Tree/","excerpt":"","text":"","categories":[],"tags":[{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"}]},{"title":"深度学习分布式训练","slug":"深度学习分布式训练","date":"2019-07-26T12:47:41.000Z","updated":"2019-11-09T05:45:06.419Z","comments":true,"path":"2019/07/26/深度学习分布式训练/","link":"","permalink":"http://yoursite.com/2019/07/26/深度学习分布式训练/","excerpt":"","text":"并行模式数据并行模型并行混合并行参考","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"architerture of sqlite","slug":"architerture-of-sqlite","date":"2019-07-26T11:10:01.000Z","updated":"2019-07-26T11:10:01.822Z","comments":true,"path":"2019/07/26/architerture-of-sqlite/","link":"","permalink":"http://yoursite.com/2019/07/26/architerture-of-sqlite/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sqlite源码剖析(1)","slug":"sqlite源码剖析-1","date":"2019-07-26T10:06:29.000Z","updated":"2019-07-26T10:06:29.996Z","comments":true,"path":"2019/07/26/sqlite源码剖析-1/","link":"","permalink":"http://yoursite.com/2019/07/26/sqlite源码剖析-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"傅立叶变换及其加强版FFT","slug":"傅立叶变换及其加强版FFT","date":"2019-07-26T09:00:39.000Z","updated":"2019-07-26T09:00:39.691Z","comments":true,"path":"2019/07/26/傅立叶变换及其加强版FFT/","link":"","permalink":"http://yoursite.com/2019/07/26/傅立叶变换及其加强版FFT/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"caffe中的卷积计算的实现im2col","slug":"caffe中的卷积计算的实现im2col","date":"2019-07-26T09:00:02.000Z","updated":"2019-07-26T09:00:02.105Z","comments":true,"path":"2019/07/26/caffe中的卷积计算的实现im2col/","link":"","permalink":"http://yoursite.com/2019/07/26/caffe中的卷积计算的实现im2col/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"GPU内存层次","slug":"GPU内存层次","date":"2019-07-25T14:03:10.000Z","updated":"2019-07-25T16:28:12.067Z","comments":true,"path":"2019/07/25/GPU内存层次/","link":"","permalink":"http://yoursite.com/2019/07/25/GPU内存层次/","excerpt":"","text":"","categories":[],"tags":[{"name":"CUDA Programming","slug":"CUDA-Programming","permalink":"http://yoursite.com/tags/CUDA-Programming/"}]},{"title":"knowledge distillation","slug":"knowledge-distillation","date":"2019-07-24T10:27:52.000Z","updated":"2019-07-24T10:27:52.665Z","comments":true,"path":"2019/07/24/knowledge-distillation/","link":"","permalink":"http://yoursite.com/2019/07/24/knowledge-distillation/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"cudnn实践","slug":"cudnn实践","date":"2019-07-23T07:31:32.000Z","updated":"2019-07-23T07:31:32.890Z","comments":true,"path":"2019/07/23/cudnn实践/","link":"","permalink":"http://yoursite.com/2019/07/23/cudnn实践/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"矩阵乘法优化cublas","slug":"矩阵乘法优化cublas","date":"2019-07-23T07:31:19.000Z","updated":"2019-07-23T07:31:19.300Z","comments":true,"path":"2019/07/23/矩阵乘法优化cublas/","link":"","permalink":"http://yoursite.com/2019/07/23/矩阵乘法优化cublas/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SIMD","slug":"intel向量化指令","date":"2019-07-23T03:36:16.000Z","updated":"2019-07-25T02:56:41.578Z","comments":true,"path":"2019/07/23/intel向量化指令/","link":"","permalink":"http://yoursite.com/2019/07/23/intel向量化指令/","excerpt":"","text":"SIMD 向量化","categories":[],"tags":[{"name":"parallel programming","slug":"parallel-programming","permalink":"http://yoursite.com/tags/parallel-programming/"}]},{"title":"model parallelism/data parallelism","slug":"model-parallelism-data-parallelism","date":"2019-07-23T03:28:02.000Z","updated":"2019-07-23T03:28:02.114Z","comments":true,"path":"2019/07/23/model-parallelism-data-parallelism/","link":"","permalink":"http://yoursite.com/2019/07/23/model-parallelism-data-parallelism/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"BSP/SSP/A-SGD","slug":"BSP-SSP-A-SGD","date":"2019-07-23T03:27:30.000Z","updated":"2019-11-22T14:17:45.796Z","comments":true,"path":"2019/07/23/BSP-SSP-A-SGD/","link":"","permalink":"http://yoursite.com/2019/07/23/BSP-SSP-A-SGD/","excerpt":"","text":"参考Angel 异步控制","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"}]},{"title":"BatchNormalization","slug":"BatchNormalization","date":"2019-07-23T02:47:27.000Z","updated":"2019-07-23T02:47:27.405Z","comments":true,"path":"2019/07/23/BatchNormalization/","link":"","permalink":"http://yoursite.com/2019/07/23/BatchNormalization/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Dropout","slug":"Dropout","date":"2019-07-23T02:47:18.000Z","updated":"2019-07-23T02:47:18.805Z","comments":true,"path":"2019/07/23/Dropout/","link":"","permalink":"http://yoursite.com/2019/07/23/Dropout/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"mixed precision","slug":"mixed-precision","date":"2019-07-22T18:18:35.000Z","updated":"2019-07-22T18:18:35.062Z","comments":true,"path":"2019/07/23/mixed-precision/","link":"","permalink":"http://yoursite.com/2019/07/23/mixed-precision/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"REVISITING DISTRIBUTED SYNCHRONOUS SGD","slug":"REVISITING-DISTRIBUTED-SYNCHRONOUS-SGD","date":"2019-07-22T16:33:50.000Z","updated":"2019-09-23T02:53:18.786Z","comments":true,"path":"2019/07/23/REVISITING-DISTRIBUTED-SYNCHRONOUS-SGD/","link":"","permalink":"http://yoursite.com/2019/07/23/REVISITING-DISTRIBUTED-SYNCHRONOUS-SGD/","excerpt":"","text":"Referencerevisiting distributed synchronous sgdDC-ASGD","categories":[],"tags":[{"name":"distributed machine learning","slug":"distributed-machine-learning","permalink":"http://yoursite.com/tags/distributed-machine-learning/"}]},{"title":"caffe源码(1)","slug":"caffe源码-1","date":"2019-07-22T08:32:37.000Z","updated":"2019-07-22T17:04:20.210Z","comments":true,"path":"2019/07/22/caffe源码-1/","link":"","permalink":"http://yoursite.com/2019/07/22/caffe源码-1/","excerpt":"","text":"","categories":[],"tags":[{"name":"caffe","slug":"caffe","permalink":"http://yoursite.com/tags/caffe/"}]},{"title":"词向量","slug":"词向量","date":"2019-07-20T01:40:58.000Z","updated":"2019-07-20T01:40:58.347Z","comments":true,"path":"2019/07/20/词向量/","link":"","permalink":"http://yoursite.com/2019/07/20/词向量/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"模型压缩","slug":"模型压缩","date":"2019-07-20T00:36:58.000Z","updated":"2019-07-20T00:36:58.138Z","comments":true,"path":"2019/07/20/模型压缩/","link":"","permalink":"http://yoursite.com/2019/07/20/模型压缩/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"bert","slug":"bert","date":"2019-07-20T00:36:39.000Z","updated":"2019-07-20T00:36:39.447Z","comments":true,"path":"2019/07/20/bert/","link":"","permalink":"http://yoursite.com/2019/07/20/bert/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"attention is all you need","slug":"attention-is-all-you-need","date":"2019-07-20T00:36:30.000Z","updated":"2019-07-20T00:36:30.344Z","comments":true,"path":"2019/07/20/attention-is-all-you-need/","link":"","permalink":"http://yoursite.com/2019/07/20/attention-is-all-you-need/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"各种激活函数总结","slug":"各种激活函数总结","date":"2019-07-20T00:35:05.000Z","updated":"2019-07-20T00:35:05.117Z","comments":true,"path":"2019/07/20/各种激活函数总结/","link":"","permalink":"http://yoursite.com/2019/07/20/各种激活函数总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sequence2sequence实现机器翻译","slug":"sequence2sequence实现机器翻译","date":"2019-07-12T07:57:16.000Z","updated":"2019-07-12T07:57:16.598Z","comments":true,"path":"2019/07/12/sequence2sequence实现机器翻译/","link":"","permalink":"http://yoursite.com/2019/07/12/sequence2sequence实现机器翻译/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"bilstm+CRF实现命名实体识别","slug":"bilstm-CRF实现命名实体识别","date":"2019-07-12T07:56:59.000Z","updated":"2019-11-05T06:52:28.898Z","comments":true,"path":"2019/07/12/bilstm-CRF实现命名实体识别/","link":"","permalink":"http://yoursite.com/2019/07/12/bilstm-CRF实现命名实体识别/","excerpt":"","text":"BiLSTMCRFTensorflow implementation参考Bidirectional LSTM-CRF Models for Sequence Tagging","categories":[],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://yoursite.com/tags/NLP/"}]},{"title":"c++11之Deducing Types","slug":"c-11之Deducing-Types","date":"2019-07-12T05:33:39.000Z","updated":"2019-07-22T17:05:12.444Z","comments":true,"path":"2019/07/12/c-11之Deducing-Types/","link":"","permalink":"http://yoursite.com/2019/07/12/c-11之Deducing-Types/","excerpt":"","text":"","categories":[],"tags":[{"name":"c++11","slug":"c-11","permalink":"http://yoursite.com/tags/c-11/"}]},{"title":"CUDA in Actions","slug":"CUDA-in-Actions","date":"2019-07-12T02:41:00.000Z","updated":"2020-01-12T04:38:28.690Z","comments":true,"path":"2019/07/12/CUDA-in-Actions/","link":"","permalink":"http://yoursite.com/2019/07/12/CUDA-in-Actions/","excerpt":"","text":"简介&nbsp;&nbsp;之前我们用cuda实现了打印hello world以及向量相加. 这篇博客，我们来探究如何利用gpu的并行性. gpu的power就在于它的并行性. &lt;&lt;&lt;…&gt;&gt;&gt;语法&nbsp;&nbsp;&lt;&lt;&lt;…&gt;&gt;&gt;是kernel函数执行的设置，比如用几个线程来执行核函数. cuda 将线程组织成线程块(thread block)，kernel可以启动很多线程块，并且把它们组织成grid数据结构(grid).&nbsp;&nbsp;核函数启动设置的语法是&lt;&lt;&lt; M , T &gt;&gt;&gt; &nbsp;&nbsp;表示kernel函数执行启动了一个grid,这个grid有M个线程块(thread block),每个线程块有T个线程. threadIdx.x, blockDim.x 以及 blockIdx.x&nbsp;&nbsp;cuda提供了内置变量来获取线程信息，这里我们使用两个. threadIdx.x 表示线程块中的线程编号(以0开始), blockIdx.x表示线程块中的线程数.因为可以获取线程信息，所以函数内部可以根据当前的线程来决定执行怎样的操作.比如向量相加，不同的线程计算不同区间的向量相加，先获取当前线程号，根据线程号确定向量相加的范围，执行计算.blockDim.x表示一个thread block的线程数量. 并行计算 vector addition假设一个线程块有256个线程 __global__ void vector_add(float *out, float *a, float *b, int n) &#123; int index = threadIdx.x; int stride = blockDim.x; for(int i = index; i &lt; n; i += stride)&#123; out[i] = a[i] + b[i]; &#125;&#125; 上面的代码的想法可以用如下的图来说明: 不同线程写不同位置，不存在冲突，这里突然想起来，如果按照一个线程的写法但是开多个线程运行，是不是应该会冲突？？之后可以学习一下gpu线程的同步问题. 我们用nvprof来验证用1个线程和256个线程完成向量相加的执行情况，主要看执行时间： 可以看到执行时间明显缩短了.现在的程序只开了一个thread block,我们尝试开启多个thread block. 多个thread block并行计算向量相加&nbsp;&nbsp;cuda提供了内置的变量来获取thread block的信息，包括block的编号(blockIdx.x)，一个grid有多少个blocks(gridDim.x).&nbsp;&nbsp;使用多个grid来并行化向量相加的示意图如下所示: &nbsp;&nbsp;想法就是每个block有256个thread,每个thread负责一个计算一个元素相加，然后总共有 N/256个thread block,因为N不一定是256的倍数，所以在核函数中还要判断index是否小于N..这样每个元素都是同时计算的,进一步加大并行化.期望的执行时间也应该减少. 对应的程序如下：__global__ void vector_add(float *out, float *a, float *b, int n) &#123; int i = blockIdx.x*blockDim.x+threadIdx.x; if(i&lt;n)out[i] = a[i] + b[i]; 程序运行性能如下: 性能比较N=700000 version Execution Time(ms) Speedup 1 thread 977.26 1.00x 1 block 5.5417 176.35x Multiple blocks 0.13274 7360.25x 总结这篇博客分别通过用一个thread block,每个thread block 256个线程和多个thread block，每个thread block 256个线程计算向量相加来展示如何使用gpu来并行计算.其中强调了三个概念 grid , threadblock以及 thread….接下来我们学习一个gpu的架构. 参考Tutorial 02 CUDA in Actions","categories":[],"tags":[{"name":"CUDA Programming","slug":"CUDA-Programming","permalink":"http://yoursite.com/tags/CUDA-Programming/"}]},{"title":"LSTM,RNN,Bi-LSTM,On-LSTM","slug":"LSTM-RNN-Bi-LSTM-On-LSTM","date":"2019-07-12T02:40:07.000Z","updated":"2019-07-12T02:40:07.846Z","comments":true,"path":"2019/07/12/LSTM-RNN-Bi-LSTM-On-LSTM/","link":"","permalink":"http://yoursite.com/2019/07/12/LSTM-RNN-Bi-LSTM-On-LSTM/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CUDA线程层次-从硬件和软件角度","slug":"GPU架构","date":"2019-07-09T16:36:31.000Z","updated":"2019-07-25T16:22:16.138Z","comments":true,"path":"2019/07/10/GPU架构/","link":"","permalink":"http://yoursite.com/2019/07/10/GPU架构/","excerpt":"","text":"Streaming MultiprocessorsGPU是由流多处理器构成的，每个SM内部有多个core, 每个core跑一个thread. The idea is that the CPU spawns a thread per element, and the GPU then executes those threads.Not all of the thousands or millions of threads actually run in parallel, but many do.Specifically, an NVIDIA GPU contains several largely independent processors called “Streaming Multiprocessors” (SMs), each SM hosts several “cores”, and each “core” runs a thread.For instance, Fermi has up to 16 SMs with 32 cores per SM – so up to 512 thread can run in parallel. All threads running on the cores of an SM at a given cycle are executing the same instruction – hence Single Instruction, Multiple Threads. However, each thread has its own registers, so these instructions process different data. &nbsp;&nbsp;可以看到一个thread block跑在一个SM上面. 一个block执行完毕，SM可以调度另一个block执行，在一个SM上,block的执行是顺序的. &nbsp;&nbsp;一个SM只有一个指令单元，SM内的所有thread共享这个指令单元. Warps&nbsp;&nbsp;一个thread block在一个SM上执行,block中的thread可以继续分成warp,一个warp包括32个线程.warp是SM调度运行的基本单元,一个warp中的所有线程执行相同的指令.任意时刻，SM中只会有一个warp在运行，其余的warp都处于就绪等其他状态. 不同架构的gpu一个SM包含不同数量的cuda核心，Turing架构的一个SM包含128个cuda core,也就是4个warp. SM中有硬件warp scheduler，用来调度warp运行. thread block organization&nbsp;&nbsp;grid由多个blocks组成，每个kernel function的调用都会create一个grid,所以&lt;&lt;&lt;…&gt;&gt;&gt;语法指定的是block的数量和每个block的线程数量,因为这个kernel函数只会在一个grid上运行. &nbsp;&nbsp;同一个block内的所有thread可以合作(因为有个Shared Memory??)，不同block的thread不可以合作. &nbsp;&nbsp;从上图中可以看到每个block都有一个Shared Memory,是所有block中的thread所共享的,每个thread有自己的Local Memory和Registers. 一个Grid中的所有blocks共享Global Memory, Constant Memory以及Texture Memory. 所有blocks中的thread都共享这三种Memory,内存层次会在后序的博客中进行总结. uint3和Dim3 数据结构uint3 dim3 block and grid dimensions#include &lt;cuda_runtime.h&gt;#include &lt;stdio.h&gt;__global__ void checkIndex(void) &#123;printf(\"threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) \"\"gridDim:(%d, %d, %d)\\n\", threadIdx.x, threadIdx.y, threadIdx.z, blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, blockDim.z, gridDim.x,gridDim.y,gridDim.z);&#125;int main(int argc, char **argv) &#123; // define total data elementint nElem = 6;// define grid and block structuredim3 block (3);dim3 grid ((nElem+block.x-1)/block.x);// check grid and block dimension from host sideprintf(\"grid.x %d grid.y %d grid.z %d\\n\",grid.x, grid.y, grid.z);printf(\"block.x %d block.y %d block.z %d\\n\",block.x, block.y, block.z);// check grid and block dimension from device side checkIndex&lt;&lt;&lt;grid, block&gt;&gt;&gt;();// reset device before you leavecudaDeviceReset();return(0);&#125; &nbsp;&nbsp;可以看到上面的程序定义了两个dim3类型的变量block和grid. 因为nElem的值是6,所以grid的x分量是2,因为这两个变量都只是指定了x分量，所以其余的分量都初始化为1.目前来看&lt;&lt;…&gt;&gt;&gt;传入的两个参数都是dim3类型的，之前的程序中直接传入int类型的,它应该会转换成dim3类型的.&nbsp;&nbsp;一个很直观的想法是可以把一个grid想像成一个三维的直角坐标系，然后一个block就是坐标系中的一个点,如果指定gridDim的x,y,z分别为2,3,4那么就有24个block,每个block可以用一个三维坐标来表示,同理可以可以把一个block想象成一个直角坐标系，thread也是其中的点. 运行结果 cudaDeviceReset可以看到这个函数是用来销毁一个CUDA的上下文的. It will reset the device immediately.虽然它表现上具有同步的功能，但是靠这个函数来同步是不安全的，所以建议如果是想同步的话，使用cudaDeviceSynchronize或者cudaMemcpy. 总结&nbsp;&nbsp;这篇博客总结了cuda线程的组织层次，从逻辑上讲一个kernel launch启动一个grid，可以用&lt;&lt;&lt;…&gt;&gt;&gt;语法设置gridDim和blockDim，从3个维度上进行设置. 一个grid包含多个block，这就是线程的两个层次的组织结构. 从硬件角度来讲，gpu的计算核心是多个SMs（streaming multiprocessors)，一个block在一个SM上运行，SM内部包含多个cuda core(不同的gpu架构的数目不同，Turing包含128个),32个cuda core构成一个warp.任意时刻一个SM中只会有一个warp处于活跃状态，其他的warp处于就绪或者挂起状态，从这点来看, SM非常类似于cpu中的core. 参考Programming Massively Parallel ProcessorsWhat is the role of cudaDeviceReset() in Cuda CUDA C Programming Guide","categories":[],"tags":[{"name":"CUDA Programming","slug":"CUDA-Programming","permalink":"http://yoursite.com/tags/CUDA-Programming/"}]},{"title":"CUDA Hello World","slug":"CUDA-Hello-World","date":"2019-07-09T07:59:38.000Z","updated":"2019-12-24T03:25:29.491Z","comments":true,"path":"2019/07/09/CUDA-Hello-World/","link":"","permalink":"http://yoursite.com/2019/07/09/CUDA-Hello-World/","excerpt":"","text":"简介&nbsp;&nbsp;第一次尝试编写CUDA C程序，主要是和以后的希望从事的方向有关，想从事大规模机器学习和深度学习系统的开发，CUDA是不可避免的需要掌握的并行计算的框架. 正好实验室有gpu服务器，趁着暑假来学习一波CUDA编程.&nbsp;&nbsp;CUDA是NVIDIA推出的运算平台，是一种并行计算的架构，使用GPU来进行通用计算. 编译CUDA程序的流程&nbsp;&nbsp;编译一个CUDA程序和C程序一样，CUDA程序的编译器是nvcc, CUDA程序文件的后缀是.cu. 开设我们有一个CUDA程序文件，命名为hello.cu, 那么我们用nvcc将它编译为可执行文件的命令如下: nvcc hello.cu -o hello CUDA Hello World&nbsp;&nbsp;学习任何程序设计语言的入门都是打印Hello World.CUDA程序也不例外， 下面我们以打印Hello World为例来解释CUDA程序的要素. #include&lt;stdio.h&gt;__global__ void hello()&#123; printf(\"hello world from GPU\\n\");&#125;int main()&#123; printf(\"hello world from CPU\\n\"); hello&lt;&lt;&lt;1, 10&gt;&gt;&gt;(); cudaDeviceSynchronize(); return 0;&#125; 我们用与之功能相近的普通C程序作为对比#include &lt;stdio.h&gt;void hello()&#123; printf(\"Hello World!\\n\");&#125;int main() &#123; hello(); return 0;&#125; 可以看到cuda程序相对于普通的c程序，有几点不同: __global__ 限定符&nbsp;&nbsp;在cuda程序中，cpu和gpu都用来做计算。我们把cpu叫做host，gpu叫做device. cpu和gpu拥有各自的存储空间。通常我们在cpu上顺序执行代码，在gpu上进行并行计算(Typically, we run serial workload on CPU and offload parallel computation to GPUs).&nbsp;&nbsp;__global__限定符表示hello函数是在gpu上执行的，是device代码,而且被该修饰符修饰的函数可以被host上的代码调用(这一点很重要，之后我们会看到，有的限定符表示只能被device代码或者只能被host代码调用)，我们的例子里hello函数就是被host上的main函数调用的,这样的函数也叫”kernels”. A kernel function must have a void return type(核函数的返回类型必须是void) &lt;&lt;&lt;…&gt;&gt;&gt; 语法&nbsp;&nbsp;当我们调用kernel的时候，它的执行的配置是通过&lt;&lt;&lt;…&gt;&gt;&gt;语法提供的，所谓的配置包括执行这个kernel用几个线程块，每个线程块开几个线程（这个涉及到gpu的结构）.比如上面的例子中，hello&lt;&lt;&lt;1, 10&gt;&gt;&gt;();. 在cuda中，这个叫做”kernel launch”(核启动). 具体参数之后的博客来说明. cudaDeviceSynchronize&nbsp;&nbsp; a kernel launch is asynchronous.因为kernel launch是异步执行的，当执行到device code的时候，在gpu上开启进程的时候，程序控制权就会回到cpu，不管gpu上的程序是否执行完毕。在我们的cuda程序中，如果没有cudaDeviceSynchronize函数，我们的程序就结束退出了，这样的话gpu端打印的hello world就不能打印到标准输出了. 而有了cudaDeviceSynchronize，cpu端的程序就会等device上的程序执行完后才退出，所以cudaDeviceSynchronize函数会阻塞直到device上的代码执行完毕. Vector Addition&nbsp;&nbsp;下面我们来看使用gpu进行向量相加运算的代码. 首先是使用cpu进行运算的代码：#define N 10000000void vector_add(float *out, float *a, float *b, int n) &#123; for(int i = 0; i &lt; n; i++)&#123; out[i] = a[i] + b[i]; &#125;&#125;int main()&#123; float *a, *b, *out; // Allocate memory a = (float*)malloc(sizeof(float) * N); b = (float*)malloc(sizeof(float) * N); out = (float*)malloc(sizeof(float) * N); // Initialize array for(int i = 0; i &lt; N; i++)&#123; a[i] = 1.0f; b[i] = 2.0f; &#125; // Main function vector_add(out, a, b, N);&#125; 下面我们把向量相加的部分放到gpu上进行并行运算:#define N 100000__global__ void vector_add(float *out, float *a, float *b, int n) &#123; for(int i = 0; i &lt; n; i++)&#123; out[i] = a[i] + b[i]; &#125;&#125;int main()&#123; float *a, *b, *out; // Allocate memory a = (float*)malloc(sizeof(float) * N); b = (float*)malloc(sizeof(float) * N); out = (float*)malloc(sizeof(float) * N); // Initialize array for(int i = 0; i &lt; N; i++)&#123; a[i] = 1.0f; b[i] = 2.0f; &#125; float *d_a; float *d_b; float *d_out; cudaMalloc((void**)&amp;d_a, sizeof(float) * N); cudaMalloc((void**)&amp;d_b, sizeof(float) * N); cudaMalloc((void**)&amp;d_out, sizeof(float) * N); cudaMemcpy(d_a, a, sizeof(float) * N, cudaMemcpyHostToDevice); cudaMemcpy(d_b, b, sizeof(float) * N, cudaMemcpyHostToDevice); cudaMemcpy(d_out, out, sizeof(float) * N, cudaMemcpyHostToDevice); // Main function vector_add&lt;&lt;&lt;1,10&gt;&gt;&gt;(d_out, d_a, d_b, N); //cudaMemcpy(a, d_a, sizeof(float) * N, cudaMemcpyDeviceToHost); //cudaMemcpy(b, d_b, sizeof(float) * N, cudaMemcpyDeviceToHost); cudaMemcpy(out, d_out, sizeof(float) * N, cudaMemcpyDeviceToHost); for(int i=0;i&lt; N;i++)&#123; printf(\"%f\\n\",out[i]); &#125; printf(\"end!!!!\"); cudaFree(d_a); cudaFree(d_b); cudaFree(d_out); free(a); free(b); free(out);&#125; &nbsp;&nbsp;可能一开始，我们会向hello world程序一样，给vector_add函数添加__global__修饰符.然后在main函数中调用vector_add函数的地方添加&lt;&lt;&lt;…&gt;&gt;&gt;. 这样以后我们编译运行程序但是发现程序的执行结果和我们预想的不一样. 是什么原因导致的呢？&nbsp;&nbsp;原因是cpu和gpu是各自拥有自己的存储空间,cpu无法直接获取gpu存储上的内容，gpu也无法直接获取到cpu存储上的内容. 在 cuda的术语里, cpu的存储叫做host memory, gpu的存储叫做device memory. 指向cpu内存的指针叫做host pointer, 指向gpu内存的指针叫做device pointer. 如果要让gpu能够获取到数据，那么数据必须在device memory上，cuda提供了分配device memory和在host和device之间进行数据迁移的api,cuda 程序的一个常见的流程如下: 分配host memory并初始化host上的数据 分配device memory(cudaMalloc) 将kernel函数要用的数据从host迁移到device上(cudaMemcpy) 执行kernel函数 将kernel函数的输出从device迁移到host上(cudaMemcpy) vec_add在gpu上运行，而out,a,b这三个向量，传入的是cpu上的地址空间，因此结果和我们预期的不一样. 这里还有个疑问，那为啥程序不报错呢，传入的是cpu上的存储地址.核函数内部居然不报错？ 这个程序相比于前面的hello world程序有很多新的函数需要解释： cudaMalloc和cudaFree&nbsp;&nbsp;这两个函数类似于c语言中的malloc和free函数，只不过这两个函数是在device memory上分配空间, 他们的函数原型如下：cudaMalloc(void **devPtr, size_t count);cudaFree(void *devPtr); cudaMalloc函数在device memory上分配size为count的空间，然后让devPtr指向分配的空间. 而 cudaFree将devPtr指向的空间给free了. cudaMemcpy&nbsp;&nbsp;cudaMemcpy函数用来在host和device之间传递数据，和c中的memcpy函数很像. 语法如下：cudaMemcpy(void *dst, void *src, size_t count, cudaMemcpyKind kind) 这个函数将size为count的存储从src复制到dst,kind指示复制的方向，最常用的值是cudaMemcpyHostToDevice 以及 cudaMemcpyDeviceToHost，分别表示从host复制到device以及从device复制到host. 参考Tutorial 01:Say Hello to CUDAwhy do we need cudaDeviceSynchronizecudaDeviceSynchronize and performing sequential work","categories":[],"tags":[{"name":"CUDA Programming","slug":"CUDA-Programming","permalink":"http://yoursite.com/tags/CUDA-Programming/"}]},{"title":"逻辑回归交叉熵损失函数梯度推导","slug":"逻辑回归交叉熵损失函数梯度推导","date":"2019-07-06T05:44:14.000Z","updated":"2019-12-23T10:13:01.359Z","comments":true,"path":"2019/07/06/逻辑回归交叉熵损失函数梯度推导/","link":"","permalink":"http://yoursite.com/2019/07/06/逻辑回归交叉熵损失函数梯度推导/","excerpt":"","text":"what is softmax&nbsp;&nbsp;softmax通常用于神经网络的输出层，用于多分类任务, 为每个类别产生一个概率，公式如下: softmax(\\overrightarrow{z})=\\overrightarrow{s}\\overrightarrow{z} \\in R^n , \\overrightarrow{s} \\in R^ns_i = \\frac{e^{z_i}}{ \\sum_{k=1}^{n} {e^{z_k}} }what is logistic regression&nbsp;&nbsp;逻辑回归是一个分类模型,假设输入$ \\overrightarrow{x} \\in R^n $, 模型参数$ \\overrightarrow{w} \\in R^n $, $ b \\in R $ ,真实标签$ y \\in \\{0,1\\} $ ,模型的预测输出是$ \\hat{y} \\in R $ 表示模型预测该实例为1的概率: P(Y=1|x) = \\hat{y} = sigmoid(w*x+b) = \\frac{1}{1+e^{-(w*x+b)}} =\\frac{e^{w*x+b}}{1+e^{w*x+b}}从而: P(Y=0|x) = \\frac{1}{1+e^{w*x+b}}sigmoid损失函数&nbsp;&nbsp;sigmoid损失函数的公式和形状如下，它能将输入的范围转化到[0,1]之间,作为概率值. sigmoid(z) = \\frac{1}{1+e^{-z}} 极大似然估计&nbsp;&nbsp;极大似然估计是一种模型参数的估计方法，是频率学派的方法（另一个是贝叶斯学派，它们的参数估计方法是最大后验概率估计,两者的区别在于极大似然估计假设模型参数是一个固定值而最大后验概率估计假设模型参数也服从一定的分布，称为先验分布). 极大似然估计假设模型的参数是$ \\Theta $,那么我们观察到的数据可以表示成参数的函数$ f(xi|\\Theta) $,一般我们是有一个数据集，根据这个数据集合来估计模型参数，那么使得这个数据集合被我们观察到的概率是 f(x_1,x_2,x_3,...x_n|\\Theta)因为数据集的数据是独立同分布的，所以下面的式子成立: f(x_1,x_2,x_3,...x_n|\\Theta) = \\prod_{i=1}^{n} {f(x_i|\\Theta)}上面的式子就是似然函数，它是一个关于参数$ \\Theta $的函数,而我们要选取使得该似然函数取得最大值的参数，这就是极大似然估计,也就是选取参数使得我们观察到的结果的可能性最大. 逻辑回归的损失函数推导&nbsp;&nbsp;逻辑回归的参数估计可以采用极大似然法，似然函数如下： \\prod_{i=1}^{n} {P(Y=1|x)^{y_i}P(Y=0|x)^{1-y_i} } = \\prod_{i=1}^{n} {\\hat{y_i}^{y_i}(1-\\hat{y_i})^{1-y_i}}我们使用负对数似然，对数函数不改变单调性，取负数使得该值大于0，那么损失函数如下： L = - \\ln( \\prod_{i=1}^{n} {\\hat{y_i}^{y_i}(1-\\hat{y_i})^{1-y_i}} ) = - \\sum_{i=1}^{n} {y_i\\ln\\hat{y_i}+(1-y_i)\\ln(1-\\hat{y_i})}我们采用梯度下降法sgd来求解模型参书$ w $, $ b $: \\frac{\\partial L}{\\partial w} = \\sum_{i=1}^{n} {\\frac{\\partial L}{\\partial \\hat{y_i}} \\frac{\\partial \\hat{y_i}}{\\partial w}}\\frac{\\partial L}{\\partial \\hat{y_i} } = - [ y_i \\frac{\\partial \\ln\\hat{y_i}}{\\partial \\hat{y_i}}+(1-y_i) \\frac{\\partial \\ln(1- \\hat{y_i})}{\\partial \\hat{y_i}} ] = - [ y_i \\frac{1}{ \\hat{y_i} } +(1-y_i) \\frac{-1}{1- \\hat{y_i}} ] = - \\frac{y_i - \\hat{y_i} }{ \\hat{y_i} (1- \\hat{y_i})}\\frac{ \\partial \\hat{y_i} }{ \\partial w} = \\hat{y_i}(1- \\hat{y_i} ) x_i综上: \\frac{\\partial L}{\\partial w} = \\sum_{i=1}^{n} {\\frac{\\partial L}{\\partial \\hat{y_i}} \\frac{\\partial \\hat{y_i}}{\\partial w}} = - \\sum_{i=1}^{n} {(y_i - \\hat{y_i})x_i }$ w $的更新公式为: w = w + \\eta \\sum_{i=1}^{n}{(y_i- \\hat{y_i})x_i }同理, $ b $的梯度如下: \\frac{\\partial L}{\\partial b} = \\sum_{i=1}^{n} {\\frac{\\partial L}{\\partial \\hat{y_i}} \\frac{\\partial \\hat{y_i}}{\\partial b}} = - \\sum_{i=1}^{n} {(y_i - \\hat{y_i}) }b的更新公式如下: b = b + \\eta \\sum_{i=1}^{n}{(y_i- \\hat{y_i}) }交叉熵损失函数以及softmax函数的梯度推导&nbsp;&nbsp;交叉熵用来衡量两个分布之间的距离,假设两个分布$ p $和$ q $,交叉熵的计算公式如下： H(p,q) = \\sum_{i=1}^{n} {p_i \\log \\frac{1}{q_i}} = \\sum_{i=1}^{n} {- p_i \\log q_i}&nbsp;&nbsp;softmax的输出是一个概率分布，而真实标签的one-hot向量也是一个概率分布，真实类别的概率为1，其余类别的概率是0，所以用交叉熵来衡量两个分布之间的距离作为损失函数是合适的，其实该损失函数也可以使用极大似然估计推导出来，下面是推导过程: L = - \\ln(\\prod_{i=1}^{n} {\\prod_{j=1}^{c} { \\hat{y_{ij}}^{y_{ij}}} }) = \\sum_{i=1}^{n} { [\\sum_{j=1}^{c} {-y_{ij} \\ln \\hat{y_{ij}}} ] }其实数据集的损失是每个数据点的损失之和，[]内部就是交叉熵，下面我们推导损失函数的梯度，首先我们假设全连接中$ z_{ij} = w_j * x_i + b_j $ , 这里的 $ wj $ 表示所有与输出层的第$ j $个神经元连接的权值，这些权值构成一个向量: \\frac{\\partial L}{\\partial w_j } = \\sum_{i=1}^{n} {\\frac{ \\partial L }{ \\partial z_{ij} } \\frac{\\partial z_{ij} }{\\partial w_j }}\\frac{ \\partial L }{ \\partial z_{ij} } = \\sum_{k=1}^{c} { \\frac{ \\partial L}{ \\partial \\hat{y_{ik}} } \\frac{ \\partial \\hat{y_{ik}}}{\\partial z_{ij}} }\\frac{\\partial L }{\\partial \\hat{y_{ik}}} = \\frac{ \\partial [ -y_{ik} \\ln \\hat{y_{ik}}] }{ \\partial \\hat{y_{ik}}}= \\frac{-y_{ik}}{ \\hat{y_{ik}}}下面得分两种情况考虑:如果 $ k=j $, \\frac{ \\partial \\hat{y_{ik}}}{\\partial z_{ij}} = \\frac{ \\partial \\frac{e^{z_{ij}}}{ \\sum_{q=1}^{c} {e^{z_{iq}}}} }{ \\partial z_{ij} } = \\frac{ e^{z_{ij}} \\sum_{q=1}^{c}{ e^{z_{iq}}} - e^{z_{ij}} e^{z_{ij}} }{ [ \\sum_{q=1}^{c} {e^{z_{iq}}} ]^{2} } = \\hat{y_{ij}} (1- \\hat{y_{ij}} )如果 $ k \\ne j $, \\frac{ \\partial \\hat{y_{ik}}}{\\partial z_{ij}} = \\frac{ \\partial \\frac{e^{z_{ik}}}{ \\sum_{q=1}^{c} {e^{z_{iq}}}} }{ \\partial z_{ij} } = \\frac{ 0- e^{z_{ik}} e^{z_{ij}} }{ [ \\sum_{q=1}^{c} {e^{z_{iq}}} ]^{2} } = - \\hat{y_{ik}} \\hat{y_{ij}}将上面的两个式子综合一下，得到如下的式子： \\frac{ \\partial L }{ \\partial z_{ij} } = - y_{ij} (1- \\hat{ y_{ij} }) + \\sum_{k \\ne j}^{c}{ y_{ik} \\hat{y_{ij}} } = -y_{ij} + \\hat{y_{ij}} \\sum_{q=1}^{c} {y_{ik}} = \\hat{ y_{ij}} -y_{ij}因为: \\frac{\\partial z_{ij}}{ \\partial w_j } = x_i\\frac{\\partial z_{ij}}{ \\partial b_j } = 1综上,$ w_j $的更新公式如下： w_j = w_j - \\eta \\sum_{i=1}^{n}{ ( \\hat{ y_{ij}} -y_{ij}) x_i }同理,b的更新公式如下： b_j = b_j - \\eta \\sum_{i=1}^{n}{ ( \\hat{ y_{ij}} -y_{ij}) }上面的公式可以由下面的代码来验证: 参考","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://yoursite.com/tags/deep-learning/"}]}],"categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"c++11","slug":"c-11","permalink":"http://yoursite.com/tags/c-11/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"data structure","slug":"data-structure","permalink":"http://yoursite.com/tags/data-structure/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"前言","slug":"前言","permalink":"http://yoursite.com/tags/前言/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"gbdt","slug":"gbdt","permalink":"http://yoursite.com/tags/gbdt/"},{"name":"operating system","slug":"operating-system","permalink":"http://yoursite.com/tags/operating-system/"},{"name":"DDL","slug":"DDL","permalink":"http://yoursite.com/tags/DDL/"},{"name":"distributed systems","slug":"distributed-systems","permalink":"http://yoursite.com/tags/distributed-systems/"},{"name":"distributed system","slug":"distributed-system","permalink":"http://yoursite.com/tags/distributed-system/"},{"name":"MPI","slug":"MPI","permalink":"http://yoursite.com/tags/MPI/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"deep learning system","slug":"deep-learning-system","permalink":"http://yoursite.com/tags/deep-learning-system/"},{"name":"deep learning","slug":"deep-learning","permalink":"http://yoursite.com/tags/deep-learning/"},{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"},{"name":"CUDA Programming","slug":"CUDA-Programming","permalink":"http://yoursite.com/tags/CUDA-Programming/"},{"name":"parallel programming","slug":"parallel-programming","permalink":"http://yoursite.com/tags/parallel-programming/"},{"name":"distributed machine learning","slug":"distributed-machine-learning","permalink":"http://yoursite.com/tags/distributed-machine-learning/"},{"name":"caffe","slug":"caffe","permalink":"http://yoursite.com/tags/caffe/"},{"name":"NLP","slug":"NLP","permalink":"http://yoursite.com/tags/NLP/"}]}